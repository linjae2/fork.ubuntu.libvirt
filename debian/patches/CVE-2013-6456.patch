Description: fix LXC driver unsafe path use under /proc/$PID/root
Origin: upstream, http://libvirt.org/git/?p=libvirt.git;a=commit;h=a15d9aa37e0baa4677c605c7563ebd92d3de468c
Origin: upstream, http://libvirt.org/git/?p=libvirt.git;a=commit;h=268ef38d12b6bf4fdcbbe6f8c7dd6c2e4cc446f1
Origin: upstream, http://libvirt.org/git/?p=libvirt.git;a=commit;h=5daffc54b0815c49146cb6174c28954252542247
Origin: upstream, http://libvirt.org/git/?p=libvirt.git;a=commit;h=aaba652d2ba2a3a258c6b36d109ada59824cedce
Origin: upstream, http://libvirt.org/git/?p=libvirt.git;a=commit;h=4428224e0d60ce32cb81be45b79323912ce5b8dc
Origin: upstream, http://libvirt.org/git/?p=libvirt.git;a=commit;h=d0ddd54a6706b7bfbc2ff1c2d3352331a8857660
Origin: upstream, http://libvirt.org/git/?p=libvirt.git;a=commit;h=869961c1a2dc718d6272b3218e0263d58d4a6648
Origin: upstream, http://libvirt.org/git/?p=libvirt.git;a=commit;h=045ab83be86ab960ab8358d96de110e98930740c
Origin: upstream, http://libvirt.org/git/?p=libvirt.git;a=commit;h=06a0f6b81cb982d8b7789862ef2e197d68d9e6ab
Origin: upstream, http://libvirt.org/git/?p=libvirt.git;a=commit;h=40c8a8e92686fb5bf55fa1482b59309d3e5b96e3
Origin: upstream, http://libvirt.org/git/?p=libvirt.git;a=commit;h=599be6a6f93618ac5094e0283538ed827b5c7e5b
Origin: upstream, http://libvirt.org/git/?p=libvirt.git;a=commit;h=05b36162178f8bf43c5ca57568f154493701b209
Origin: upstream, http://libvirt.org/git/?p=libvirt.git;a=commit;h=6ecb7bc3aed7f60edad5289c9b0cfcf99eee6611
Origin: upstream, http://libvirt.org/git/?p=libvirt.git;a=commit;h=72a4c29ca72789b13de1ed9cb96df9fb2b0fdde4
Origin: upstream, http://libvirt.org/git/?p=libvirt.git;a=commit;h=83f83508e128275bd1b74988162dc6b9f86e00ee
Origin: upstream, http://libvirt.org/git/?p=libvirt.git;a=commit;h=398c88edfaef50b9b59eb2d9a61b07c9c940a661
Origin: upstream, http://libvirt.org/git/?p=libvirt.git;a=commit;h=dd055960df60c536957664f0ae3c591feecf7b09
Origin: upstream, http://libvirt.org/git/?p=libvirt.git;a=commit;h=14d69bd00e4455a1d174d14c5af73975cf9e904a
Bug-Debian: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=732394

Index: libvirt-1.1.1/src/lxc/lxc_driver.c
===================================================================
--- libvirt-1.1.1.orig/src/lxc/lxc_driver.c	2014-05-05 14:15:07.416625739 -0400
+++ libvirt-1.1.1/src/lxc/lxc_driver.c	2014-05-05 14:15:07.400625739 -0400
@@ -2664,12 +2664,20 @@
 
 
 static int
+lxcDomainInitctlCallback(pid_t pid ATTRIBUTE_UNUSED,
+                         void *opaque)
+{
+    int *command = opaque;
+    return virInitctlSetRunLevel(*command);
+}
+
+
+static int
 lxcDomainShutdownFlags(virDomainPtr dom,
                        unsigned int flags)
 {
     virLXCDomainObjPrivatePtr priv;
     virDomainObjPtr vm;
-    char *vroot = NULL;
     int ret = -1;
     int rc;
 
@@ -2696,16 +2704,14 @@
         goto cleanup;
     }
 
-    if (virAsprintf(&vroot, "/proc/%llu/root",
-                    (unsigned long long)priv->initpid) < 0)
-        goto cleanup;
-
     if (flags == 0 ||
         (flags & VIR_DOMAIN_SHUTDOWN_INITCTL)) {
-        if ((rc = virInitctlSetRunLevel(VIR_INITCTL_RUNLEVEL_POWEROFF,
-                                        vroot)) < 0) {
+        int command = VIR_INITCTL_RUNLEVEL_POWEROFF;
+
+        if ((rc = virProcessRunInMountNamespace(priv->initpid,
+                                                lxcDomainInitctlCallback,
+                                                &command)) < 0)
             goto cleanup;
-        }
         if (rc == 0 && flags != 0 &&
             ((flags & ~VIR_DOMAIN_SHUTDOWN_INITCTL) == 0)) {
             virReportError(VIR_ERR_OPERATION_UNSUPPORTED, "%s",
@@ -2731,7 +2737,6 @@
     ret = 0;
 
 cleanup:
-    VIR_FREE(vroot);
     if (vm)
         virObjectUnlock(vm);
     return ret;
@@ -2743,13 +2748,13 @@
     return lxcDomainShutdownFlags(dom, 0);
 }
 
+
 static int
 lxcDomainReboot(virDomainPtr dom,
                 unsigned int flags)
 {
     virLXCDomainObjPrivatePtr priv;
     virDomainObjPtr vm;
-    char *vroot = NULL;
     int ret = -1;
     int rc;
 
@@ -2776,16 +2781,14 @@
         goto cleanup;
     }
 
-    if (virAsprintf(&vroot, "/proc/%llu/root",
-                    (unsigned long long)priv->initpid) < 0)
-        goto cleanup;
-
     if (flags == 0 ||
         (flags & VIR_DOMAIN_REBOOT_INITCTL)) {
-        if ((rc = virInitctlSetRunLevel(VIR_INITCTL_RUNLEVEL_REBOOT,
-                                        vroot)) < 0) {
+        int command = VIR_INITCTL_RUNLEVEL_REBOOT;
+
+        if ((rc = virProcessRunInMountNamespace(priv->initpid,
+                                                lxcDomainInitctlCallback,
+                                                &command)) < 0)
             goto cleanup;
-        }
         if (rc == 0 && flags != 0 &&
             ((flags & ~VIR_DOMAIN_SHUTDOWN_INITCTL) == 0)) {
             virReportError(VIR_ERR_OPERATION_UNSUPPORTED, "%s",
@@ -2811,7 +2814,6 @@
     ret = 0;
 
 cleanup:
-    VIR_FREE(vroot);
     if (vm)
         virObjectUnlock(vm);
     return ret;
@@ -2982,6 +2984,155 @@
 }
 
 
+struct lxcDomainAttachDeviceMknodData {
+    virLXCDriverPtr driver;
+    mode_t mode;
+    dev_t dev;
+    virDomainObjPtr vm;
+    virDomainDeviceDefPtr def;
+    char *file;
+};
+
+static int
+lxcDomainAttachDeviceMknodHelper(pid_t pid ATTRIBUTE_UNUSED,
+                                 void *opaque)
+{
+    struct lxcDomainAttachDeviceMknodData *data = opaque;
+    int ret = -1;
+
+    virSecurityManagerPostFork(data->driver->securityManager);
+
+    if (virFileMakeParentPath(data->file) < 0) {
+        virReportSystemError(errno,
+                             _("Unable to create %s"), data->file);
+        goto cleanup;
+    }
+
+    /* Yes, the device name we're creating may not
+     * actually correspond to the major:minor number
+     * we're using, but we've no other option at this
+     * time. Just have to hope that containerized apps
+     * don't get upset that the major:minor is different
+     * to that normally implied by the device name
+     */
+    VIR_DEBUG("Creating dev %s (%d,%d)",
+              data->file, major(data->dev), minor(data->dev));
+    if (mknod(data->file, data->mode, data->dev) < 0) {
+        virReportSystemError(errno,
+                             _("Unable to create device %s"),
+                             data->file);
+        goto cleanup;
+    }
+
+    if (lxcContainerChown(data->vm->def, data->file) < 0)
+        goto cleanup;
+
+    /* Labelling normally operates on src, but we need
+     * to actually label the dst here, so hack the config */
+    switch (data->def->type) {
+    case VIR_DOMAIN_DEVICE_DISK: {
+        virDomainDiskDefPtr def = data->def->data.disk;
+        char *tmpsrc = def->src;
+        def->src = data->file;
+        if (virSecurityManagerSetImageLabel(data->driver->securityManager,
+                                            data->vm->def, def) < 0) {
+            def->src = tmpsrc;
+            goto cleanup;
+        }
+        def->src = tmpsrc;
+    }   break;
+
+    case VIR_DOMAIN_DEVICE_HOSTDEV: {
+        virDomainHostdevDefPtr def = data->def->data.hostdev;
+        if (virSecurityManagerSetHostdevLabel(data->driver->securityManager,
+                                              data->vm->def, def, NULL) < 0)
+            goto cleanup;
+    }   break;
+
+    default:
+        virReportError(VIR_ERR_INTERNAL_ERROR,
+                       _("Unexpected device type %d"),
+                       data->def->type);
+        goto cleanup;
+    }
+
+    ret = 0;
+
+ cleanup:
+    if (ret < 0)
+        unlink(data->file);
+    return ret;
+}
+
+
+static int
+lxcDomainAttachDeviceMknod(virLXCDriverPtr driver,
+                           mode_t mode,
+                           dev_t dev,
+                           virDomainObjPtr vm,
+                           virDomainDeviceDefPtr def,
+                           char *file)
+{
+    virLXCDomainObjPrivatePtr priv = vm->privateData;
+    struct lxcDomainAttachDeviceMknodData data;
+
+    memset(&data, 0, sizeof(data));
+
+    data.driver = driver;
+    data.mode = mode;
+    data.dev = dev;
+    data.vm = vm;
+    data.def = def;
+    data.file = file;
+
+    if (virSecurityManagerPreFork(driver->securityManager) < 0)
+        return -1;
+
+    if (virProcessRunInMountNamespace(priv->initpid,
+                                      lxcDomainAttachDeviceMknodHelper,
+                                      &data) < 0) {
+        virSecurityManagerPostFork(driver->securityManager);
+        return -1;
+    }
+
+    virSecurityManagerPostFork(driver->securityManager);
+    return 0;
+}
+
+
+static int
+lxcDomainAttachDeviceUnlinkHelper(pid_t pid ATTRIBUTE_UNUSED,
+                                  void *opaque)
+{
+    const char *path = opaque;
+
+    VIR_DEBUG("Unlinking %s", path);
+    if (unlink(path) < 0 && errno != ENOENT) {
+        virReportSystemError(errno,
+                             _("Unable to remove device %s"), path);
+        return -1;
+    }
+
+    return 0;
+}
+
+
+static int
+lxcDomainAttachDeviceUnlink(virDomainObjPtr vm,
+                            char *file)
+{
+    virLXCDomainObjPrivatePtr priv = vm->privateData;
+
+    if (virProcessRunInMountNamespace(priv->initpid,
+                                      lxcDomainAttachDeviceUnlinkHelper,
+                                      file) < 0) {
+        return -1;
+    }
+
+    return 0;
+}
+
+
 static int
 lxcDomainAttachDeviceDiskLive(virLXCDriverPtr driver,
                               virDomainObjPtr vm,
@@ -2990,11 +3141,9 @@
     virLXCDomainObjPrivatePtr priv = vm->privateData;
     virDomainDiskDefPtr def = dev->data.disk;
     int ret = -1;
-    char *dst = NULL;
     struct stat sb;
-    bool created = false;
-    mode_t mode = 0;
-    char *tmpsrc = def->src;
+    char *file = NULL;
+    int perms;
 
     if (!priv->initpid) {
         virReportError(VIR_ERR_OPERATION_INVALID, "%s",
@@ -3002,6 +3151,12 @@
         goto cleanup;
     }
 
+    if (!virCgroupHasController(priv->cgroup, VIR_CGROUP_CONTROLLER_DEVICES)) {
+        virReportError(VIR_ERR_OPERATION_INVALID, "%s",
+                       _("devices cgroup isn't mounted"));
+        goto cleanup;
+    }
+
     if (def->type != VIR_DOMAIN_DISK_TYPE_BLOCK) {
         virReportError(VIR_ERR_CONFIG_UNSUPPORTED, "%s",
                        _("Can't setup disk for non-block device"));
@@ -3025,68 +3180,51 @@
         goto cleanup;
     }
 
-    if (!S_ISCHR(sb.st_mode) && !S_ISBLK(sb.st_mode)) {
+    if (!S_ISBLK(sb.st_mode)) {
         virReportError(VIR_ERR_CONFIG_UNSUPPORTED,
-                       _("Disk source %s must be a character/block device"),
+                       _("Disk source %s must be a block device"),
                        def->src);
         goto cleanup;
     }
 
-    if (virAsprintf(&dst, "/proc/%llu/root/dev/%s",
-                    (unsigned long long)priv->initpid, def->dst) < 0)
-        goto cleanup;
-
-    if (VIR_REALLOC_N(vm->def->disks, vm->def->ndisks+1) < 0)
-        goto cleanup;
-
-    mode = 0700;
-    if (S_ISCHR(sb.st_mode))
-        mode |= S_IFCHR;
-    else
-        mode |= S_IFBLK;
-
-    /* Yes, the device name we're creating may not
-     * actually correspond to the major:minor number
-     * we're using, but we've no other option at this
-     * time. Just have to hope that containerized apps
-     * don't get upset that the major:minor is different
-     * to that normally implied by the device name
-     */
-    VIR_DEBUG("Creating dev %s (%d,%d) from %s",
-              dst, major(sb.st_rdev), minor(sb.st_rdev), def->src);
-    if (mknod(dst, mode, sb.st_rdev) < 0) {
-        virReportSystemError(errno,
-                             _("Unable to create device %s"),
-                             dst);
-        goto cleanup;
-    }
-
-    if (lxcContainerChown(vm->def, dst) < 0)
-        goto cleanup;
-
-    created = true;
-
-    /* Labelling normally operates on src, but we need
-     * to actally label the dst here, so hack the config */
-    def->src = dst;
-    if (virSecurityManagerSetImageLabel(driver->securityManager,
-                                        vm->def, def) < 0)
-        goto cleanup;
-
     if (!virCgroupHasController(priv->cgroup, VIR_CGROUP_CONTROLLER_DEVICES)) {
         virReportError(VIR_ERR_OPERATION_INVALID, "%s",
                        _("devices cgroup isn't mounted"));
         goto cleanup;
     }
 
-    if (virCgroupAllowDevicePath(priv->cgroup, def->src,
-                                 (def->readonly ?
-                                  VIR_CGROUP_DEVICE_READ :
-                                  VIR_CGROUP_DEVICE_RW) |
-                                 VIR_CGROUP_DEVICE_MKNOD) != 0) {
-        virReportError(VIR_ERR_INTERNAL_ERROR,
-                       _("cannot allow device %s for domain %s"),
-                       def->src, vm->def->name);
+    perms = (def->readonly ?
+             VIR_CGROUP_DEVICE_READ :
+             VIR_CGROUP_DEVICE_RW) |
+        VIR_CGROUP_DEVICE_MKNOD;
+
+    if (virCgroupAllowDevice(priv->cgroup,
+                             'b',
+                             major(sb.st_rdev),
+                             minor(sb.st_rdev),
+                             perms) < 0)
+        goto cleanup;
+
+    if (VIR_REALLOC_N(vm->def->disks, vm->def->ndisks + 1) < 0)
+        goto cleanup;
+
+    if (virAsprintf(&file,
+                    "/dev/%s", def->dst) < 0)
+        goto cleanup;
+
+    if (lxcDomainAttachDeviceMknod(driver,
+                                   0700 | S_IFBLK,
+                                   sb.st_rdev,
+                                   vm,
+                                   dev,
+                                   file) < 0) {
+        if (virCgroupDenyDevice(priv->cgroup,
+                                'b',
+                                major(sb.st_rdev),
+                                minor(sb.st_rdev),
+                                perms) < 0)
+            VIR_WARN("cannot deny device %s for domain %s",
+                     def->src, vm->def->name);
         goto cleanup;
     }
 
@@ -3095,10 +3233,8 @@
     ret = 0;
 
 cleanup:
-    def->src = tmpsrc;
     virDomainAuditDisk(vm, NULL, def->src, "attach", ret == 0);
-    if (dst && created && ret < 0)
-        unlink(dst);
+    VIR_FREE(file);
     return ret;
 }
 
@@ -3240,13 +3376,8 @@
     virLXCDomainObjPrivatePtr priv = vm->privateData;
     virDomainHostdevDefPtr def = dev->data.hostdev;
     int ret = -1;
-    char *vroot = NULL;
     char *src = NULL;
-    char *dstdir = NULL;
-    char *dstfile = NULL;
     struct stat sb;
-    mode_t mode;
-    bool created = false;
     virUSBDevicePtr usb = NULL;
 
     if (virDomainHostdevFind(vm->def, def, NULL) >= 0) {
@@ -3255,33 +3386,13 @@
         return -1;
     }
 
-    if (virAsprintf(&vroot, "/proc/%llu/root",
-                    (unsigned long long)priv->initpid) < 0)
-        goto cleanup;
-
-    if (virAsprintf(&dstdir, "%s/dev/bus/%03d",
-                    vroot,
-                    def->source.subsys.u.usb.bus) < 0)
-        goto cleanup;
-
-    if (virAsprintf(&dstfile, "%s/%03d",
-                    dstdir,
-                    def->source.subsys.u.usb.device) < 0)
-        goto cleanup;
-
     if (virAsprintf(&src, "/dev/bus/usb/%03d/%03d",
                     def->source.subsys.u.usb.bus,
                     def->source.subsys.u.usb.device) < 0)
         goto cleanup;
 
-    if (!virCgroupHasController(priv->cgroup, VIR_CGROUP_CONTROLLER_DEVICES)) {
-        virReportError(VIR_ERR_OPERATION_INVALID, "%s",
-                       _("devices cgroup isn't mounted"));
-        goto cleanup;
-    }
-
     if (!(usb = virUSBDeviceNew(def->source.subsys.u.usb.bus,
-                                def->source.subsys.u.usb.device, vroot)))
+                                def->source.subsys.u.usb.device, NULL)))
         goto cleanup;
 
     if (stat(src, &sb) < 0) {
@@ -3297,48 +3408,36 @@
         goto cleanup;
     }
 
-    mode = 0700 | S_IFCHR;
-
-    if (virFileMakePath(dstdir) < 0) {
-        virReportSystemError(errno,
-                             _("Unable to create %s"), dstdir);
-        goto cleanup;
-    }
-
-    VIR_DEBUG("Creating dev %s (%d,%d)",
-              dstfile, major(sb.st_rdev), minor(sb.st_rdev));
-    if (mknod(dstfile, mode, sb.st_rdev) < 0) {
-        virReportSystemError(errno,
-                             _("Unable to create device %s"),
-                             dstfile);
+    if (VIR_REALLOC_N(vm->def->hostdevs, vm->def->nhostdevs + 1) < 0)
         goto cleanup;
-    }
-    created = true;
 
-    if (lxcContainerChown(vm->def, dstfile) < 0)
+    if (virUSBDeviceFileIterate(usb,
+                                virLXCSetupHostUsbDeviceCgroup,
+                                priv->cgroup) < 0)
         goto cleanup;
 
-    if (virSecurityManagerSetHostdevLabel(driver->securityManager,
-                                          vm->def, def, vroot) < 0)
+    if (lxcDomainAttachDeviceMknod(driver,
+                                   0700 | S_IFCHR,
+                                   sb.st_rdev,
+                                   vm,
+                                   dev,
+                                   src) < 0) {
+        if (virUSBDeviceFileIterate(usb,
+                                    virLXCTeardownHostUsbDeviceCgroup,
+                                    priv->cgroup) < 0)
+            VIR_WARN("cannot deny device %s for domain %s",
+                     src, vm->def->name);
         goto cleanup;
+    }
 
-    if (virUSBDeviceFileIterate(usb,
-                                virLXCSetupHostUsbDeviceCgroup,
-                                &priv->cgroup) < 0)
-        goto cleanup;
+    vm->def->hostdevs[vm->def->nhostdevs++] = def;
 
     ret = 0;
 
 cleanup:
     virDomainAuditHostdev(vm, def, "attach", ret == 0);
-    if (ret < 0 && created)
-        unlink(dstfile);
-
     virUSBDeviceFree(usb);
     VIR_FREE(src);
-    VIR_FREE(dstfile);
-    VIR_FREE(dstdir);
-    VIR_FREE(vroot);
     return ret;
 }
 
@@ -3351,11 +3450,7 @@
     virLXCDomainObjPrivatePtr priv = vm->privateData;
     virDomainHostdevDefPtr def = dev->data.hostdev;
     int ret = -1;
-    char *dst = NULL;
-    char *vroot = NULL;
     struct stat sb;
-    bool created = false;
-    mode_t mode = 0;
 
     if (!def->source.caps.u.storage.block) {
         virReportError(VIR_ERR_CONFIG_UNSUPPORTED, "%s",
@@ -3383,57 +3478,29 @@
         goto cleanup;
     }
 
-    if (virAsprintf(&vroot, "/proc/%llu/root",
-                    (unsigned long long)priv->initpid) < 0)
-        goto cleanup;
-
-    if (virAsprintf(&dst, "%s/%s",
-                    vroot,
-                    def->source.caps.u.storage.block) < 0)
-        goto cleanup;
-
     if (VIR_REALLOC_N(vm->def->hostdevs, vm->def->nhostdevs+1) < 0)
         goto cleanup;
 
-    if (lxcContainerSetupHostdevCapsMakePath(dst) < 0) {
-        virReportSystemError(errno,
-                             _("Unable to create directroy for device %s"),
-                             dst);
-        goto cleanup;
-    }
-
-    mode = 0700 | S_IFBLK;
-
-    VIR_DEBUG("Creating dev %s (%d,%d)",
-              def->source.caps.u.storage.block,
-              major(sb.st_rdev), minor(sb.st_rdev));
-    if (mknod(dst, mode, sb.st_rdev) < 0) {
-        virReportSystemError(errno,
-                             _("Unable to create device %s"),
-                             dst);
-        goto cleanup;
-    }
-    created = true;
-
-    if (lxcContainerChown(vm->def, dst) < 0)
-        goto cleanup;
-
-    if (virSecurityManagerSetHostdevLabel(driver->securityManager,
-                                          vm->def, def, vroot) < 0)
-        goto cleanup;
-
-    if (!virCgroupHasController(priv->cgroup, VIR_CGROUP_CONTROLLER_DEVICES)) {
-        virReportError(VIR_ERR_OPERATION_INVALID, "%s",
-                       _("devices cgroup isn't mounted"));
-        goto cleanup;
-    }
-
-    if (virCgroupAllowDevicePath(priv->cgroup, def->source.caps.u.storage.block,
-                                 VIR_CGROUP_DEVICE_RW |
-                                 VIR_CGROUP_DEVICE_MKNOD) != 0) {
-        virReportError(VIR_ERR_INTERNAL_ERROR,
-                       _("cannot allow device %s for domain %s"),
-                       def->source.caps.u.storage.block, vm->def->name);
+    if (virCgroupAllowDevice(priv->cgroup,
+                             'b',
+                             major(sb.st_rdev),
+                             minor(sb.st_rdev),
+                             VIR_CGROUP_DEVICE_RWM) < 0)
+        goto cleanup;
+
+    if (lxcDomainAttachDeviceMknod(driver,
+                                   0700 | S_IFBLK,
+                                   sb.st_rdev,
+                                   vm,
+                                   dev,
+                                   def->source.caps.u.storage.block) < 0) {
+        if (virCgroupDenyDevice(priv->cgroup,
+                                'b',
+                                major(sb.st_rdev),
+                                minor(sb.st_rdev),
+                                VIR_CGROUP_DEVICE_RWM) < 0)
+            VIR_WARN("cannot deny device %s for domain %s",
+                     def->source.caps.u.storage.block, vm->def->name);
         goto cleanup;
     }
 
@@ -3443,10 +3510,6 @@
 
 cleanup:
     virDomainAuditHostdev(vm, def, "attach", ret == 0);
-    if (dst && created && ret < 0)
-        unlink(dst);
-    VIR_FREE(dst);
-    VIR_FREE(vroot);
     return ret;
 }
 
@@ -3459,11 +3522,7 @@
     virLXCDomainObjPrivatePtr priv = vm->privateData;
     virDomainHostdevDefPtr def = dev->data.hostdev;
     int ret = -1;
-    char *dst = NULL;
-    char *vroot = NULL;
     struct stat sb;
-    bool created = false;
-    mode_t mode = 0;
 
     if (!def->source.caps.u.misc.chardev) {
         virReportError(VIR_ERR_CONFIG_UNSUPPORTED, "%s",
@@ -3491,57 +3550,29 @@
         goto cleanup;
     }
 
-    if (virAsprintf(&vroot, "/proc/%llu/root",
-                    (unsigned long long)priv->initpid) < 0)
-        goto cleanup;
-
-    if (virAsprintf(&dst, "%s/%s",
-                    vroot,
-                    def->source.caps.u.misc.chardev) < 0)
+    if (virCgroupAllowDevice(priv->cgroup,
+                             'c',
+                             major(sb.st_rdev),
+                             minor(sb.st_rdev),
+                             VIR_CGROUP_DEVICE_RWM) < 0)
         goto cleanup;
 
     if (VIR_REALLOC_N(vm->def->hostdevs, vm->def->nhostdevs+1) < 0)
         goto cleanup;
 
-    if (lxcContainerSetupHostdevCapsMakePath(dst) < 0) {
-        virReportSystemError(errno,
-                             _("Unable to create directroy for device %s"),
-                             dst);
-        goto cleanup;
-    }
-
-    mode = 0700 | S_IFCHR;
-
-    VIR_DEBUG("Creating dev %s (%d,%d)",
-              def->source.caps.u.misc.chardev,
-              major(sb.st_rdev), minor(sb.st_rdev));
-    if (mknod(dst, mode, sb.st_rdev) < 0) {
-        virReportSystemError(errno,
-                             _("Unable to create device %s"),
-                             dst);
-        goto cleanup;
-    }
-    created = true;
-
-    if (lxcContainerChown(vm->def, dst) < 0)
-        goto cleanup;
-
-    if (virSecurityManagerSetHostdevLabel(driver->securityManager,
-                                          vm->def, def, vroot) < 0)
-        goto cleanup;
-
-    if (!virCgroupHasController(priv->cgroup, VIR_CGROUP_CONTROLLER_DEVICES)) {
-        virReportError(VIR_ERR_OPERATION_INVALID, "%s",
-                       _("devices cgroup isn't mounted"));
-        goto cleanup;
-    }
-
-    if (virCgroupAllowDevicePath(priv->cgroup, def->source.caps.u.misc.chardev,
-                                 VIR_CGROUP_DEVICE_RW |
-                                 VIR_CGROUP_DEVICE_MKNOD) != 0) {
-        virReportError(VIR_ERR_INTERNAL_ERROR,
-                       _("cannot allow device %s for domain %s"),
-                       def->source.caps.u.misc.chardev, vm->def->name);
+    if (lxcDomainAttachDeviceMknod(driver,
+                                   0700 | S_IFBLK,
+                                   sb.st_rdev,
+                                   vm,
+                                   dev,
+                                   def->source.caps.u.misc.chardev) < 0) {
+        if (virCgroupDenyDevice(priv->cgroup,
+                                'c',
+                                major(sb.st_rdev),
+                                minor(sb.st_rdev),
+                                VIR_CGROUP_DEVICE_RWM) < 0)
+            VIR_WARN("cannot deny device %s for domain %s",
+                     def->source.caps.u.storage.block, vm->def->name);
         goto cleanup;
     }
 
@@ -3551,10 +3582,6 @@
 
 cleanup:
     virDomainAuditHostdev(vm, def, "attach", ret == 0);
-    if (dst && created && ret < 0)
-        unlink(dst);
-    VIR_FREE(dst);
-    VIR_FREE(vroot);
     return ret;
 }
 
@@ -3611,6 +3638,12 @@
         return -1;
     }
 
+    if (!virCgroupHasController(priv->cgroup, VIR_CGROUP_CONTROLLER_DEVICES)) {
+        virReportError(VIR_ERR_OPERATION_INVALID, "%s",
+                       _("devices cgroup isn't mounted"));
+        return -1;
+    }
+
     switch (dev->data.hostdev->mode) {
     case VIR_DOMAIN_HOSTDEV_MODE_SUBSYS:
         return lxcDomainAttachDeviceHostdevSubsysLive(driver, vm, dev);
@@ -3691,8 +3724,7 @@
 
     def = vm->def->disks[idx];
 
-    if (virAsprintf(&dst, "/proc/%llu/root/dev/%s",
-                    (unsigned long long)priv->initpid, def->dst) < 0)
+    if (virAsprintf(&dst, "/dev/%s", def->dst) < 0)
         goto cleanup;
 
     if (!virCgroupHasController(priv->cgroup, VIR_CGROUP_CONTROLLER_DEVICES)) {
@@ -3701,11 +3733,8 @@
         goto cleanup;
     }
 
-    VIR_DEBUG("Unlinking %s (backed by %s)", dst, def->src);
-    if (unlink(dst) < 0 && errno != ENOENT) {
+    if (lxcDomainAttachDeviceUnlink(vm, dst) < 0) {
         virDomainAuditDisk(vm, def->src, NULL, "detach", false);
-        virReportSystemError(errno,
-                             _("Unable to remove device %s"), dst);
         goto cleanup;
     }
     virDomainAuditDisk(vm, def->src, NULL, "detach", true);
@@ -3800,7 +3829,6 @@
     virDomainHostdevDefPtr def = NULL;
     int idx, ret = -1;
     char *dst = NULL;
-    char *vroot;
     virUSBDevicePtr usb = NULL;
 
     if ((idx = virDomainHostdevFind(vm->def,
@@ -3811,12 +3839,7 @@
         goto cleanup;
     }
 
-    if (virAsprintf(&vroot, "/proc/%llu/root",
-                    (unsigned long long)priv->initpid) < 0)
-        goto cleanup;
-
-    if (virAsprintf(&dst, "%s/dev/bus/usb/%03d/%03d",
-                    vroot,
+    if (virAsprintf(&dst, "/dev/bus/usb/%03d/%03d",
                     def->source.subsys.u.usb.bus,
                     def->source.subsys.u.usb.device) < 0)
         goto cleanup;
@@ -3828,21 +3851,18 @@
     }
 
     if (!(usb = virUSBDeviceNew(def->source.subsys.u.usb.bus,
-                                def->source.subsys.u.usb.device, vroot)))
+                                def->source.subsys.u.usb.device, NULL)))
         goto cleanup;
 
-    VIR_DEBUG("Unlinking %s", dst);
-    if (unlink(dst) < 0 && errno != ENOENT) {
+    if (lxcDomainAttachDeviceUnlink(vm, dst) < 0) {
         virDomainAuditHostdev(vm, def, "detach", false);
-        virReportSystemError(errno,
-                             _("Unable to remove device %s"), dst);
         goto cleanup;
     }
     virDomainAuditHostdev(vm, def, "detach", true);
 
     if (virUSBDeviceFileIterate(usb,
                                 virLXCTeardownHostUsbDeviceCgroup,
-                                &priv->cgroup) < 0)
+                                priv->cgroup) < 0)
         VIR_WARN("cannot deny device %s for domain %s",
                  dst, vm->def->name);
 
@@ -3869,7 +3889,6 @@
     virLXCDomainObjPrivatePtr priv = vm->privateData;
     virDomainHostdevDefPtr def = NULL;
     int idx, ret = -1;
-    char *dst = NULL;
 
     if (!priv->initpid) {
         virReportError(VIR_ERR_OPERATION_INVALID, "%s",
@@ -3886,22 +3905,14 @@
         goto cleanup;
     }
 
-    if (virAsprintf(&dst, "/proc/%llu/root/%s",
-                    (unsigned long long)priv->initpid,
-                    def->source.caps.u.storage.block) < 0)
-        goto cleanup;
-
     if (!virCgroupHasController(priv->cgroup, VIR_CGROUP_CONTROLLER_DEVICES)) {
         virReportError(VIR_ERR_OPERATION_INVALID, "%s",
                        _("devices cgroup isn't mounted"));
         goto cleanup;
     }
 
-    VIR_DEBUG("Unlinking %s", dst);
-    if (unlink(dst) < 0 && errno != ENOENT) {
+    if (lxcDomainAttachDeviceUnlink(vm, def->source.caps.u.storage.block) < 0) {
         virDomainAuditHostdev(vm, def, "detach", false);
-        virReportSystemError(errno,
-                             _("Unable to remove device %s"), dst);
         goto cleanup;
     }
     virDomainAuditHostdev(vm, def, "detach", true);
@@ -3916,7 +3927,6 @@
     ret = 0;
 
 cleanup:
-    VIR_FREE(dst);
     return ret;
 }
 
@@ -3928,7 +3938,6 @@
     virLXCDomainObjPrivatePtr priv = vm->privateData;
     virDomainHostdevDefPtr def = NULL;
     int idx, ret = -1;
-    char *dst = NULL;
 
     if (!priv->initpid) {
         virReportError(VIR_ERR_OPERATION_INVALID, "%s",
@@ -3945,22 +3954,14 @@
         goto cleanup;
     }
 
-    if (virAsprintf(&dst, "/proc/%llu/root/%s",
-                    (unsigned long long)priv->initpid,
-                    def->source.caps.u.misc.chardev) < 0)
-        goto cleanup;
-
     if (!virCgroupHasController(priv->cgroup, VIR_CGROUP_CONTROLLER_DEVICES)) {
         virReportError(VIR_ERR_OPERATION_INVALID, "%s",
                        _("devices cgroup isn't mounted"));
         goto cleanup;
     }
 
-    VIR_DEBUG("Unlinking %s", dst);
-    if (unlink(dst) < 0 && errno != ENOENT) {
+    if (lxcDomainAttachDeviceUnlink(vm, def->source.caps.u.misc.chardev) < 0) {
         virDomainAuditHostdev(vm, def, "detach", false);
-        virReportSystemError(errno,
-                             _("Unable to remove device %s"), dst);
         goto cleanup;
     }
     virDomainAuditHostdev(vm, def, "detach", true);
@@ -3975,7 +3976,6 @@
     ret = 0;
 
 cleanup:
-    VIR_FREE(dst);
     return ret;
 }
 
Index: libvirt-1.1.1/src/util/virinitctl.c
===================================================================
--- libvirt-1.1.1.orig/src/util/virinitctl.c	2014-05-05 14:15:07.416625739 -0400
+++ libvirt-1.1.1/src/util/virinitctl.c	2014-05-05 14:15:07.400625739 -0400
@@ -111,16 +111,18 @@
 # endif
 
 /*
- * Send a message to init to change the runlevel
+ * Send a message to init to change the runlevel. This function is
+ * asynchronous-signal-safe (thus safe to use after fork of a
+ * multithreaded parent) - which is good, because it should only be
+ * used after forking and entering correct namespace.
  *
  * Returns 1 on success, 0 if initctl does not exist, -1 on error
  */
-int virInitctlSetRunLevel(virInitctlRunLevel level,
-                          const char *vroot)
+int
+virInitctlSetRunLevel(virInitctlRunLevel level)
 {
     struct virInitctlRequest req;
     int fd = -1;
-    char *path = NULL;
     int ret = -1;
 
     memset(&req, 0, sizeof(req));
@@ -131,36 +133,28 @@
     /* Yes it is an 'int' field, but wants a numeric character. Go figure */
     req.runlevel = '0' + level;
 
-    if (vroot) {
-        if (virAsprintf(&path, "%s/%s", vroot, VIR_INITCTL_FIFO) < 0)
-            return -1;
-    } else {
-        if (VIR_STRDUP(path, VIR_INITCTL_FIFO) < 0)
-            return -1;
-    }
-
-    if ((fd = open(path, O_WRONLY|O_NONBLOCK|O_CLOEXEC|O_NOCTTY)) < 0) {
+    if ((fd = open(VIR_INITCTL_FIFO,
+                   O_WRONLY|O_NONBLOCK|O_CLOEXEC|O_NOCTTY)) < 0) {
         if (errno == ENOENT) {
             ret = 0;
             goto cleanup;
         }
         virReportSystemError(errno,
                              _("Cannot open init control %s"),
-                             path);
+                             VIR_INITCTL_FIFO);
         goto cleanup;
     }
 
     if (safewrite(fd, &req, sizeof(req)) != sizeof(req)) {
         virReportSystemError(errno,
                              _("Failed to send request to init control %s"),
-                             path);
+                             VIR_INITCTL_FIFO);
         goto cleanup;
     }
 
     ret = 1;
 
 cleanup:
-    VIR_FREE(path);
     VIR_FORCE_CLOSE(fd);
     return ret;
 }
Index: libvirt-1.1.1/src/util/virinitctl.h
===================================================================
--- libvirt-1.1.1.orig/src/util/virinitctl.h	2014-05-05 14:15:07.416625739 -0400
+++ libvirt-1.1.1/src/util/virinitctl.h	2014-05-05 14:15:07.404625739 -0400
@@ -37,7 +37,6 @@
     VIR_INITCTL_RUNLEVEL_LAST
 };
 
-int virInitctlSetRunLevel(virInitctlRunLevel level,
-                          const char *vroot);
+int virInitctlSetRunLevel(virInitctlRunLevel level);
 
 #endif
Index: libvirt-1.1.1/src/libvirt_private.syms
===================================================================
--- libvirt-1.1.1.orig/src/libvirt_private.syms	2014-05-05 14:15:07.416625739 -0400
+++ libvirt-1.1.1/src/libvirt_private.syms	2014-05-05 14:15:07.404625739 -0400
@@ -1375,6 +1375,7 @@
 virFileLinkPointsTo;
 virFileLock;
 virFileLoopDeviceAssociate;
+virFileMakeParentPath;
 virFileMakePath;
 virFileMakePathWithMode;
 virFileMatchesNameSuffix;
@@ -1383,6 +1384,7 @@
 virFileOpenTty;
 virFilePrintf;
 virFileReadAll;
+virFileReadHeaderFD;
 virFileReadLimFD;
 virFileResolveAllLinks;
 virFileResolveLink;
@@ -1802,6 +1804,7 @@
 virProcessGetStartTime;
 virProcessKill;
 virProcessKillPainfully;
+virProcessRunInMountNamespace;
 virProcessSetAffinity;
 virProcessSetMaxFiles;
 virProcessSetMaxMemLock;
Index: libvirt-1.1.1/src/util/virprocess.c
===================================================================
--- libvirt-1.1.1.orig/src/util/virprocess.c	2014-05-05 14:15:07.416625739 -0400
+++ libvirt-1.1.1/src/util/virprocess.c	2014-05-05 14:15:07.404625739 -0400
@@ -46,6 +46,7 @@
 #include "virlog.h"
 #include "virutil.h"
 #include "virstring.h"
+#include "vircommand.h"
 
 #define VIR_FROM_THIS VIR_FROM_NONE
 
@@ -847,3 +848,108 @@
     return 0;
 }
 #endif
+
+
+#ifdef HAVE_SETNS
+static int virProcessNamespaceHelper(int errfd,
+                                     pid_t pid,
+                                     virProcessNamespaceCallback cb,
+                                     void *opaque)
+{
+    char *path;
+    int fd = -1;
+    int ret = -1;
+
+    if (virAsprintf(&path, "/proc/%llu/ns/mnt", (unsigned long long)pid) < 0)
+        goto cleanup;
+
+    if ((fd = open(path, O_RDONLY)) < 0) {
+        virReportSystemError(errno, "%s",
+                             _("Kernel does not provide mount namespace"));
+        goto cleanup;
+    }
+
+    if (setns(fd, 0) < 0) {
+        virReportSystemError(errno, "%s",
+                             _("Unable to enter mount namespace"));
+        goto cleanup;
+    }
+
+    ret = cb(pid, opaque);
+
+ cleanup:
+    if (ret < 0) {
+        virErrorPtr err = virGetLastError();
+        if (err) {
+            size_t len = strlen(err->message) + 1;
+            ignore_value(safewrite(errfd, err->message, len));
+        }
+    }
+    VIR_FREE(path);
+    VIR_FORCE_CLOSE(fd);
+    return ret;
+}
+
+/* Run cb(opaque) in the mount namespace of pid.  Return -1 with error
+ * message raised if we fail to run the child, if the child dies from
+ * a signal, or if the child has status 1; otherwise return the exit
+ * status of the child. The callback will be run in a child process
+ * so must be careful to only use async signal safe functions.
+ */
+int
+virProcessRunInMountNamespace(pid_t pid,
+                              virProcessNamespaceCallback cb,
+                              void *opaque)
+{
+    int ret = -1;
+    pid_t child = -1;
+    int errfd[2] = { -1, -1 };
+
+    if (pipe(errfd) < 0) {
+        virReportSystemError(errno, "%s",
+                             _("Cannot create pipe for child"));
+        return -1;
+    }
+
+    ret = virFork(&child);
+
+    if (ret < 0 || child < 0) {
+        if (child == 0)
+            _exit(1);
+
+        /* parent */
+        virProcessAbort(child);
+        goto cleanup;
+    }
+
+    if (child == 0) {
+        VIR_FORCE_CLOSE(errfd[0]);
+        ret = virProcessNamespaceHelper(errfd[1], pid,
+                                        cb, opaque);
+        VIR_FORCE_CLOSE(errfd[1]);
+        _exit(ret < 0 ? 1 : 0);
+    } else {
+        char *buf = NULL;
+        VIR_FORCE_CLOSE(errfd[1]);
+
+        ignore_value(virFileReadHeaderFD(errfd[0], 1024, &buf));
+        ret = virProcessWait(child, NULL);
+        VIR_FREE(buf);
+    }
+
+cleanup:
+    VIR_FORCE_CLOSE(errfd[0]);
+    VIR_FORCE_CLOSE(errfd[1]);
+    return ret;
+}
+#else /* !HAVE_SETNS */
+int
+virProcessRunInMountNamespace(pid_t pid ATTRIBUTE_UNUSED,
+                              virProcessNamespaceCallback cb ATTRIBUTE_UNUSED,
+                              void *opaque ATTRIBUTE_UNUSED)
+{
+    virReportSystemError(ENOSYS, "%s",
+                         _("Mount namespaces are not available on this platform"));
+    return -1;
+}
+#endif
Index: libvirt-1.1.1/src/util/virprocess.h
===================================================================
--- libvirt-1.1.1.orig/src/util/virprocess.h	2014-05-05 14:15:07.416625739 -0400
+++ libvirt-1.1.1/src/util/virprocess.h	2014-05-05 14:15:07.404625739 -0400
@@ -60,4 +60,15 @@
 int virProcessSetMaxMemLock(pid_t pid, unsigned long long bytes);
 int virProcessSetMaxProcesses(pid_t pid, unsigned int procs);
 int virProcessSetMaxFiles(pid_t pid, unsigned int files);
+
+/* Callback to run code within the mount namespace tied to the given
+ * pid.  This function must use only async-signal-safe functions, as
+ * it gets run after a fork of a multi-threaded process.  The return
+ * value of this function is passed to _exit(), except that a
+ * negative value is treated as an error.  */
+typedef int (*virProcessNamespaceCallback)(pid_t pid, void *opaque);
+
+int virProcessRunInMountNamespace(pid_t pid,
+                                  virProcessNamespaceCallback cb,
+                                  void *opaque);
 #endif /* __VIR_PROCESS_H__ */
Index: libvirt-1.1.1/src/util/virfile.c
===================================================================
--- libvirt-1.1.1.orig/src/util/virfile.c	2014-05-05 14:15:07.416625739 -0400
+++ libvirt-1.1.1/src/util/virfile.c	2014-05-05 14:15:07.404625739 -0400
@@ -1149,6 +1149,27 @@
     return NULL;
 }
 
+
+/* A wrapper around saferead_lim that merely stops reading at the
+ * specified maximum size.  */
+int
+virFileReadHeaderFD(int fd, int maxlen, char **buf)
+{
+    size_t len;
+    char *s;
+
+    if (maxlen <= 0) {
+        errno = EINVAL;
+        return -1;
+    }
+    s = saferead_lim(fd, maxlen, &len);
+    if (s == NULL)
+        return -1;
+    *buf = s;
+    return len;
+}
+
+
 /* A wrapper around saferead_lim that maps a failure due to
    exceeding the maximum size limitation to EOVERFLOW.  */
 int
@@ -2068,6 +2089,35 @@
     return ret;
 }
 
+
+int
+virFileMakeParentPath(const char *path)
+{
+    char *p;
+    char *tmp;
+    int ret = -1;
+
+    VIR_DEBUG("path=%s", path);
+
+    if (VIR_STRDUP(tmp, path) < 0) {
+        errno = ENOMEM;
+        return -1;
+    }
+
+    if ((p = strrchr(tmp, '/')) == NULL) {
+        errno = EINVAL;
+        goto cleanup;
+    }
+    *p = '\0';
+
+    ret = virFileMakePathHelper(tmp, 0777);
+
+ cleanup:
+    VIR_FREE(tmp);
+    return ret;
+}
+
+
 /* Build up a fully qualified path for a config file to be
  * associated with a persistent guest or network */
 char *
Index: libvirt-1.1.1/src/util/virfile.h
===================================================================
--- libvirt-1.1.1.orig/src/util/virfile.h	2014-05-05 14:15:07.416625739 -0400
+++ libvirt-1.1.1/src/util/virfile.h	2014-05-05 14:15:07.404625739 -0400
@@ -122,9 +122,12 @@
 
 int virFileDeleteTree(const char *dir);
 
-int virFileReadLimFD(int fd, int maxlen, char **buf) ATTRIBUTE_RETURN_CHECK;
-
-int virFileReadAll(const char *path, int maxlen, char **buf) ATTRIBUTE_RETURN_CHECK;
+int virFileReadHeaderFD(int fd, int maxlen, char **buf)
+    ATTRIBUTE_RETURN_CHECK ATTRIBUTE_NONNULL(3);
+int virFileReadLimFD(int fd, int maxlen, char **buf)
+    ATTRIBUTE_RETURN_CHECK ATTRIBUTE_NONNULL(3);
+int virFileReadAll(const char *path, int maxlen, char **buf)
+    ATTRIBUTE_RETURN_CHECK ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(3);
 
 int virFileWriteStr(const char *path, const char *str, mode_t mode)
     ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2) ATTRIBUTE_RETURN_CHECK;
@@ -184,6 +187,7 @@
 int virFileMakePath(const char *path) ATTRIBUTE_RETURN_CHECK;
 int virFileMakePathWithMode(const char *path,
                             mode_t mode) ATTRIBUTE_RETURN_CHECK;
+int virFileMakeParentPath(const char *path) ATTRIBUTE_RETURN_CHECK;
 
 char *virFileBuildPath(const char *dir,
                        const char *name,
Index: libvirt-1.1.1/src/util/virstoragefile.c
===================================================================
--- libvirt-1.1.1.orig/src/util/virstoragefile.c	2014-05-05 14:15:07.416625739 -0400
+++ libvirt-1.1.1/src/util/virstoragefile.c	2014-05-05 14:15:07.408625739 -0400
@@ -781,10 +781,7 @@
         goto cleanup;
     }
 
-    if (VIR_ALLOC_N(buf, len) < 0)
-        goto cleanup;
-
-    if ((len = read(fd, buf, len)) < 0) {
+    if ((len = virFileReadHeaderFD(fd, len, (char **)&buf)) < 0) {
         virReportSystemError(errno, _("cannot read header '%s'"), path);
         goto cleanup;
     }
@@ -927,15 +924,12 @@
         return VIR_STORAGE_FILE_DIR;
     }
 
-    if (VIR_ALLOC_N(head, len) < 0)
-        return -1;
-
     if (lseek(fd, 0, SEEK_SET) == (off_t)-1) {
         virReportSystemError(errno, _("cannot set to start of '%s'"), path);
         goto cleanup;
     }
 
-    if ((len = read(fd, head, len)) < 0) {
+    if ((len = virFileReadHeaderFD(fd, len, (char **)&head)) < 0) {
         virReportSystemError(errno, _("cannot read header '%s'"), path);
         goto cleanup;
     }
Index: libvirt-1.1.1/src/conf/domain_conf.c
===================================================================
--- libvirt-1.1.1.orig/src/conf/domain_conf.c	2014-05-05 14:15:07.416625739 -0400
+++ libvirt-1.1.1/src/conf/domain_conf.c	2014-05-05 14:15:07.412625739 -0400
@@ -16921,6 +16921,7 @@
                              virDomainDeviceDefPtr dev)
 {
     if (!virDomainDefHasUSB(def) &&
+        STRNEQ(def->os.type, "exe") &&
         virDomainDeviceIsUSB(dev)) {
         virReportError(VIR_ERR_CONFIG_UNSUPPORTED, "%s",
                        _("Device configuration is not compatible: "
