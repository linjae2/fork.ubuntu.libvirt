Origin: c567853089a2764c964002dd752e09e318524a38 (adapted)
Description: fix for CVE-2010-2242
    Apply a source port mapping to virtual network masquerading

    IPtables will seek to preserve the source port unchanged when
    doing masquerading, if possible. NFS has a pseudo-security
    option where it checks for the source port <= 1023 before
    allowing a mount request. If an admin has used this to make the
    host OS trusted for mounts, the default iptables behaviour will
    potentially allow NAT'd guests access too. This needs to be
    stopped.

    With this change, the iptables -t nat -L -n -v rules for the
    default network will be

    Chain POSTROUTING (policy ACCEPT 95 packets, 9163 bytes)
     pkts bytes target     prot opt in     out     source               destination
       14   840 MASQUERADE  tcp  --  *      *       192.168.122.0/24    !192.168.122.0/24    masq ports: 1024-65535
       75  5752 MASQUERADE  udp  --  *      *       192.168.122.0/24    !192.168.122.0/24    masq ports: 1024-65535
        0     0 MASQUERADE  all  --  *      *       192.168.122.0/24    !192.168.122.0/24

Index: libvirt-0.4.0/src/iptables.c
===================================================================
--- libvirt-0.4.0.orig/src/iptables.c	2010-09-02 13:16:13.000000000 -0500
+++ libvirt-0.4.0/src/iptables.c	2010-09-02 13:18:03.000000000 -0500
@@ -1041,23 +1041,47 @@
 iptablesForwardMasquerade(iptablesContext *ctx,
                        const char *network,
                        const char *physdev,
+                       const char *protocol,
                        int action)
 {
-    if (physdev && physdev[0]) {
-        return iptablesAddRemoveRule(ctx->nat_postrouting,
-                                     action,
-                                     "--source", network,
-                                     "--destination", "!", network,
-                                     "--out-interface", physdev,
-                                     "--jump", "MASQUERADE",
-                                     NULL);
+    if (protocol && protocol[0]) {
+        if (physdev && physdev[0]) {
+            return iptablesAddRemoveRule(ctx->nat_postrouting,
+                                         action,
+                                         "--source", network,
+                                         "-p", protocol,
+                                         "--destination", "!", network,
+                                         "--out-interface", physdev,
+                                         "--jump", "MASQUERADE",
+                                         "--to-ports", "1024-65535",
+                                         NULL);
+        } else {
+            return iptablesAddRemoveRule(ctx->nat_postrouting,
+                                         action,
+                                         "--source", network,
+                                         "-p", protocol,
+                                         "--destination", "!", network,
+                                         "--jump", "MASQUERADE",
+                                         "--to-ports", "1024-65535",
+                                         NULL);
+        }
     } else {
-        return iptablesAddRemoveRule(ctx->nat_postrouting,
-                                     action,
-                                     "--source", network,
-                                     "--destination", "!", network,
-                                     "--jump", "MASQUERADE",
-                                     NULL);
+        if (physdev && physdev[0]) {
+            return iptablesAddRemoveRule(ctx->nat_postrouting,
+                                         action,
+                                         "--source", network,
+                                         "--destination", "!", network,
+                                         "--out-interface", physdev,
+                                         "--jump", "MASQUERADE",
+                                         NULL);
+        } else {
+            return iptablesAddRemoveRule(ctx->nat_postrouting,
+                                         action,
+                                         "--source", network,
+                                         "--destination", "!", network,
+                                         "--jump", "MASQUERADE",
+                                         NULL);
+        }
     }
 }
 
@@ -1066,7 +1090,8 @@
  * @ctx: pointer to the IP table context
  * @network: the source network name
  * @physdev: the physical input device or NULL
- * 
+ * @protocol: the network protocol or NULL
+ *
  * Add rules to the IP table context to allow masquerading
  * network @network on @physdev. This allow the bridge to
  * masquerade for that network (on @physdev).
@@ -1076,9 +1101,10 @@
 int
 iptablesAddForwardMasquerade(iptablesContext *ctx,
                              const char *network,
-                             const char *physdev)
+                             const char *physdev,
+                             const char *protocol)
 {
-    return iptablesForwardMasquerade(ctx, network, physdev, ADD);
+    return iptablesForwardMasquerade(ctx, network, physdev, protocol, ADD);
 }
 
 /**
@@ -1086,7 +1112,8 @@
  * @ctx: pointer to the IP table context
  * @network: the source network name
  * @physdev: the physical input device or NULL
- * 
+ * @protocol: the network protocol or NULL
+ *
  * Remove rules from the IP table context to stop masquerading
  * network @network on @physdev. This stops the bridge from
  * masquerading for that network (on @physdev).
@@ -1096,9 +1123,10 @@
 int
 iptablesRemoveForwardMasquerade(iptablesContext *ctx,
                                 const char *network,
-                                const char *physdev)
+                                const char *physdev,
+                                const char *protocol)
 {
-    return iptablesForwardMasquerade(ctx, network, physdev, REMOVE);
+    return iptablesForwardMasquerade(ctx, network, physdev, protocol, REMOVE);
 }
 
 #endif /* WITH_QEMU */
Index: libvirt-0.4.0/src/iptables.h
===================================================================
--- libvirt-0.4.0.orig/src/iptables.h	2007-12-07 09:00:48.000000000 -0600
+++ libvirt-0.4.0/src/iptables.h	2010-09-02 13:16:13.000000000 -0500
@@ -80,10 +80,12 @@
 
 int              iptablesAddForwardMasquerade    (iptablesContext *ctx,
                                                   const char *network,
-                                                  const char *physdev);
+                                                  const char *physdev,
+                                                  const char *protocol);
 int              iptablesRemoveForwardMasquerade (iptablesContext *ctx,
                                                   const char *network,
-                                                  const char *physdev);
+                                                  const char *physdev,
+                                                  const char *protocol);
 
 #endif /* WITH_QEMU */
 
Index: libvirt-0.4.0/src/qemu_driver.c
===================================================================
--- libvirt-0.4.0.orig/src/qemu_driver.c	2010-09-02 13:16:13.000000000 -0500
+++ libvirt-0.4.0/src/qemu_driver.c	2010-09-02 13:16:13.000000000 -0500
@@ -1034,18 +1034,74 @@
         goto err9;
     }
 
-    /* enable masquerading */
+    /*
+     * Enable masquerading.
+     *
+     * We need to end up with 3 rules in the table in this order
+     *
+     *  1. protocol=tcp with sport mapping restricton
+     *  2. protocol=udp with sport mapping restricton
+     *  3. generic any protocol
+     *
+     * The sport mappings are required, because default IPtables
+     * MASQUERADE is maintain port number unchanged where possible.
+     *
+     * NFS can be configured to only "trust" port numbers < 1023.
+     *
+     * Guests using NAT thus need to be prevented from having port
+     * numbers < 1023, otherwise they can bypass the NFS "security"
+     * check on the source port number.
+     *
+     * Since we use '--insert' to add rules to the header of the
+     * chain, we actually need to add them in the reverse of the
+     * order just mentioned !
+     */
+
+    /* First the generic masquerade rule for other protocols */
     if ((err = iptablesAddForwardMasquerade(driver->iptables,
                                             network->def->network,
-                                            network->def->forwardDev))) {
+                                            network->def->forwardDev,
+                                            NULL))) {
         qemudReportError(conn, NULL, NULL, VIR_ERR_INTERNAL_ERROR,
                          "failed to add iptables rule to enable masquerading : %s\n",
                          strerror(err));
         goto err10;
     }
 
+    /* UDP with a source port restriction */
+    if ((err = iptablesAddForwardMasquerade(driver->iptables,
+                                            network->def->network,
+                                            network->def->forwardDev,
+                                            "udp"))) {
+        qemudReportError(conn, NULL, NULL, VIR_ERR_INTERNAL_ERROR,
+                             "failed to add iptables rule to enable UDP masquerading to '%s'",
+                             strerror(err));
+        goto err11;
+    }
+
+    /* TCP with a source port restriction */
+    if ((err = iptablesAddForwardMasquerade(driver->iptables,
+                                            network->def->network,
+                                            network->def->forwardDev,
+                                            "tcp"))) {
+        qemudReportError(conn, NULL, NULL, VIR_ERR_INTERNAL_ERROR,
+                             "failed to add iptables rule to enable TCP masquerading to '%s'",
+                             strerror(err));
+        goto err12;
+    }
+
     return 1;
 
+ err12:
+    iptablesRemoveForwardMasquerade(driver->iptables,
+                                    network->def->network,
+                                    network->def->forwardDev,
+                                    "udp");
+ err11:
+    iptablesRemoveForwardMasquerade(driver->iptables,
+                                    network->def->network,
+                                    network->def->forwardDev,
+                                    NULL);
  err10:
     iptablesRemoveForwardAllowIn(driver->iptables,
                                  network->def->network,
@@ -1083,7 +1139,16 @@
     if (network->def->forward) {
         iptablesRemoveForwardMasquerade(driver->iptables,
                                      network->def->network,
-                                     network->def->forwardDev);
+                                     network->def->forwardDev,
+                                     "tcp");
+        iptablesRemoveForwardMasquerade(driver->iptables,
+                                     network->def->network,
+                                     network->def->forwardDev,
+                                     "udp");
+        iptablesRemoveForwardMasquerade(driver->iptables,
+                                     network->def->network,
+                                     network->def->forwardDev,
+                                     NULL);
         iptablesRemoveForwardAllowIn(driver->iptables,
                                    network->def->network,
                                    network->bridge,
