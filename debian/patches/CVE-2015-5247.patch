Description: fix denial of service via NFS pool volume creation failure
Origin: upstream, http://libvirt.org/git/?p=libvirt.git;a=commit;h=9e48400f4606bac16b7e4db195f610928c3d5a04
Origin: upstream, http://libvirt.org/git/?p=libvirt.git;a=commit;h=2f4b41861c1729ff4b754986782d7428ccdca455
Origin: upstream, http://libvirt.org/git/?p=libvirt.git;a=commit;h=7f0505705c70f7eb1e435a2e7732d1a74abfadfd
Bug-Debian: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=799132

Index: libvirt-1.2.16/src/libvirt_private.syms
===================================================================
--- libvirt-1.2.16.orig/src/libvirt_private.syms	2016-01-08 09:40:33.000000000 -0500
+++ libvirt-1.2.16/src/libvirt_private.syms	2016-01-08 10:11:27.812913971 -0500
@@ -1439,6 +1439,7 @@
 virFileSkipRoot;
 virFileStripSuffix;
 virFileTouch;
+virFileUnlink;
 virFileUnlock;
 virFileUpdatePerm;
 virFileWaitForDevices;
Index: libvirt-1.2.16/src/storage/storage_backend.c
===================================================================
--- libvirt-1.2.16.orig/src/storage/storage_backend.c	2016-01-08 09:40:33.000000000 -0500
+++ libvirt-1.2.16/src/storage/storage_backend.c	2016-01-08 10:11:22.736866895 -0500
@@ -479,6 +479,7 @@
     int fd = -1;
     int operation_flags;
     bool reflink_copy = false;
+    mode_t open_mode = VIR_STORAGE_DEFAULT_VOL_PERM_MODE;
 
     virCheckFlags(VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA |
                   VIR_STORAGE_VOL_CREATE_REFLINK,
@@ -511,11 +512,12 @@
     if (pool->def->type == VIR_STORAGE_POOL_NETFS)
         operation_flags |= VIR_FILE_OPEN_FORK;
 
+    if (vol->target.perms->mode != (mode_t) -1)
+        open_mode = vol->target.perms->mode;
+
     if ((fd = virFileOpenAs(vol->target.path,
                             O_RDWR | O_CREAT | O_EXCL,
-                            (vol->target.perms->mode ?
-                             VIR_STORAGE_DEFAULT_VOL_PERM_MODE :
-                             vol->target.perms->mode),
+                            open_mode,
                             vol->target.perms->uid,
                             vol->target.perms->gid,
                             operation_flags)) < 0) {
Index: libvirt-1.2.16/src/storage/storage_backend_fs.c
===================================================================
--- libvirt-1.2.16.orig/src/storage/storage_backend_fs.c	2015-05-29 03:13:18.000000000 -0400
+++ libvirt-1.2.16/src/storage/storage_backend_fs.c	2016-01-08 10:11:27.812913971 -0500
@@ -1185,7 +1185,8 @@
 
     switch ((virStorageVolType) vol->type) {
     case VIR_STORAGE_VOL_FILE:
-        if (unlink(vol->target.path) < 0) {
+        if (virFileUnlink(vol->target.path, vol->target.perms->uid,
+                          vol->target.perms->gid) < 0) {
             /* Silently ignore failures where the vol has already gone away */
             if (errno != ENOENT) {
                 virReportSystemError(errno,
Index: libvirt-1.2.16/src/storage/storage_driver.c
===================================================================
--- libvirt-1.2.16.orig/src/storage/storage_driver.c	2015-05-29 03:13:18.000000000 -0400
+++ libvirt-1.2.16/src/storage/storage_driver.c	2016-01-08 10:11:24.920887146 -0500
@@ -1872,8 +1872,12 @@
     }
 
     if (backend->refreshVol &&
-        backend->refreshVol(obj->conn, pool, voldef) < 0)
+        backend->refreshVol(obj->conn, pool, voldef) < 0) {
+        storageVolDeleteInternal(volobj, backend, pool, voldef,
+                                 0, false);
+        voldef = NULL;
         goto cleanup;
+    }
 
     /* Update pool metadata ignoring the disk backend since
      * it updates the pool values.
Index: libvirt-1.2.16/src/util/virfile.c
===================================================================
--- libvirt-1.2.16.orig/src/util/virfile.c	2015-05-26 21:26:03.000000000 -0400
+++ libvirt-1.2.16/src/util/virfile.c	2016-01-08 10:11:27.812913971 -0500
@@ -2280,6 +2280,112 @@
     return ret;
 }
 
+
+/* virFileUnlink:
+ * @path: file to unlink
+ * @uid: uid that was used to create the file (not required)
+ * @gid: gid that was used to create the file (not required)
+ *
+ * If a file/volume was created in an NFS root-squash environment,
+ * then we must 'unlink' the file in the same environment. Unlike
+ * the virFileOpenAs[Forked] and virDirCreate[NoFork], this code
+ * takes no extra flags and does not bother with EACCES failures
+ * from the child.
+ */
+int
+virFileUnlink(const char *path,
+              uid_t uid,
+              gid_t gid)
+{
+    pid_t pid;
+    int waitret;
+    int status, ret = 0;
+    gid_t *groups;
+    int ngroups;
+
+    /* If not running as root or if a non explicit uid/gid was being used for
+     * the file/volume, then use unlink directly
+     */
+    if ((geteuid() != 0) ||
+        ((uid == (uid_t) -1) && (gid == (gid_t) -1)))
+        return unlink(path);
+
+    /* Otherwise, we have to deal with the NFS root-squash craziness
+     * to run under the uid/gid that created the volume in order to
+     * perform the unlink of the volume.
+     */
+    if (uid == (uid_t) -1)
+        uid = geteuid();
+    if (gid == (gid_t) -1)
+        gid = getegid();
+
+    ngroups = virGetGroupList(uid, gid, &groups);
+    if (ngroups < 0)
+        return -errno;
+
+    pid = virFork();
+
+    if (pid < 0) {
+        ret = -errno;
+        VIR_FREE(groups);
+        return ret;
+    }
+
+    if (pid) { /* parent */
+        /* wait for child to complete, and retrieve its exit code */
+        VIR_FREE(groups);
+
+        while ((waitret = waitpid(pid, &status, 0)) == -1 && errno == EINTR);
+        if (waitret == -1) {
+            ret = -errno;
+            virReportSystemError(errno,
+                                 _("failed to wait for child unlinking '%s'"),
+                                 path);
+            goto parenterror;
+        }
+
+        /*
+         * If waitpid succeeded, but if the child exited abnormally or
+         * reported non-zero status, report failure
+         */
+        if (!WIFEXITED(status) || (WEXITSTATUS(status)) != 0) {
+            char *msg = virProcessTranslateStatus(status);
+            virReportError(VIR_ERR_INTERNAL_ERROR,
+                           _("child failed to unlink '%s': %s"),
+                           path, msg);
+            VIR_FREE(msg);
+            if (WIFEXITED(status))
+                ret = -WEXITSTATUS(status);
+            else
+                ret = -EACCES;
+        }
+
+ parenterror:
+        return ret;
+    }
+
+    /* child */
+
+    /* set desired uid/gid, then attempt to unlink the file */
+    if (virSetUIDGID(uid, gid, groups, ngroups) < 0) {
+        ret = errno;
+        goto childerror;
+    }
+
+    if (unlink(path) < 0) {
+        ret = errno;
+        goto childerror;
+    }
+
+ childerror:
+    if ((ret & 0xff) != ret) {
+        VIR_WARN("unable to pass desired return value %d", ret);
+        ret = 0xff;
+    }
+    _exit(ret);
+}
+
+
 /* return -errno on failure, or 0 on success */
 static int
 virDirCreateNoFork(const char *path,
Index: libvirt-1.2.16/src/util/virfile.h
===================================================================
--- libvirt-1.2.16.orig/src/util/virfile.h	2015-05-23 08:56:12.000000000 -0400
+++ libvirt-1.2.16/src/util/virfile.h	2016-01-08 10:11:27.812913971 -0500
@@ -219,6 +219,7 @@
                   uid_t uid, gid_t gid,
                   unsigned int flags)
     ATTRIBUTE_NONNULL(1) ATTRIBUTE_RETURN_CHECK;
+int virFileUnlink(const char *path, uid_t uid, gid_t gid);
 
 enum {
     VIR_DIR_CREATE_NONE        = 0,
