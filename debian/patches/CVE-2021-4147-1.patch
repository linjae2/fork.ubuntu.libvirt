Backport of:

From 23b51d7b8ec885e97a9277cf0a6c2833db4636e8 Mon Sep 17 00:00:00 2001
From: Jim Fehlig <jfehlig@suse.com>
Date: Fri, 29 Oct 2021 14:16:33 -0600
Subject: [PATCH] libxl: Disable death events after receiving a shutdown event
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

The libxl driver will handle all domain destruction and cleanup
when receiving a domain shutdown event from libxl. Commit fa30ee04a2a
introduced the ignoreDeathEvent boolean in the DomainObjPrivate struct
to ignore subsequent death events from libxl. But libxl already provides
a mechanism to disable death events via libxl_evdisable_domain_death.

This patch partially reverts commit fa30ee04a2a and instead uses
libxl_evdisable_domain_death to disable subsequent death events when
processing a shutdown event.

Signed-off-by: Jim Fehlig <jfehlig@suse.com>
Reviewed-by: Daniel P. Berrangé <berrange@redhat.com>
Reviewed-by: Ján Tomko <jtomko@redhat.com>
---
 src/libxl/libxl_domain.c | 23 +++++------------------
 src/libxl/libxl_domain.h |  3 ---
 2 files changed, 5 insertions(+), 21 deletions(-)

--- a/src/libxl/libxl_domain.c
+++ b/src/libxl/libxl_domain.c
@@ -554,12 +554,6 @@ static void
 libxlDomainHandleDeath(libxlDriverPrivatePtr driver, virDomainObjPtr vm)
 {
     virObjectEventPtr dom_event = NULL;
-    libxlDomainObjPrivatePtr priv = vm->privateData;
-
-    if (priv->ignoreDeathEvent) {
-        priv->ignoreDeathEvent = false;
-        return;
-    }
 
     if (libxlDomainObjBeginJob(driver, vm, LIBXL_JOB_MODIFY) < 0)
         return;
@@ -608,7 +602,6 @@ libxlDomainEventHandler(void *data, VIR_
     }
 
     if (event->type == LIBXL_EVENT_TYPE_DOMAIN_SHUTDOWN) {
-        libxlDomainObjPrivatePtr priv = vm->privateData;
         struct libxlShutdownThreadInfo *shutdown_info = NULL;
         virThread thread;
         char *name = NULL;
@@ -627,12 +620,9 @@ libxlDomainEventHandler(void *data, VIR_
             goto cleanup;
         /*
          * Cleanup will be handled by the shutdown thread.
-         * Ignore the forthcoming death event from libxl
          */
-        priv->ignoreDeathEvent = true;
         if (virThreadCreateFull(&thread, false, libxlDomainShutdownThread,
                                 name, false, shutdown_info) < 0) {
-             priv->ignoreDeathEvent = false;
             /*
              * Not much we can do on error here except log it.
              */
@@ -766,18 +756,17 @@ libxlDomainDestroyInternal(libxlDriverPr
     libxlDomainObjPrivatePtr priv = vm->privateData;
     int ret = -1;
 
-    /* Ignore next LIBXL_EVENT_TYPE_DOMAIN_DEATH as the caller will handle
-     * domain death appropriately already (having more info, like the reason).
-     */
-    priv->ignoreDeathEvent = true;
+    if (priv->deathW) {
+        libxl_evdisable_domain_death(cfg->ctx, priv->deathW);
+        priv->deathW = NULL;
+    }
+
     /* Unlock virDomainObj during destroy, which can take considerable
      * time on large memory domains.
      */
     virObjectUnlock(vm);
     ret = libxl_domain_destroy(cfg->ctx, vm->def->id, NULL);
     virObjectLock(vm);
-    if (ret)
-        priv->ignoreDeathEvent = false;
 
     virObjectUnref(cfg);
     return ret;
@@ -829,8 +818,6 @@ libxlDomainCleanup(libxlDriverPrivatePtr
         priv->deathW = NULL;
     }
 
-    priv->ignoreDeathEvent = false;
-
     if (virAtomicIntDecAndTest(&driver->nactive) && driver->inhibitCallback)
         driver->inhibitCallback(false, driver->inhibitOpaque);
 
--- a/src/libxl/libxl_domain.h
+++ b/src/libxl/libxl_domain.h
@@ -65,9 +65,6 @@ struct _libxlDomainObjPrivate {
     /* console */
     virChrdevsPtr devs;
     libxl_evgen_domain_death *deathW;
-    /* Flag to indicate the upcoming LIBXL_EVENT_TYPE_DOMAIN_DEATH is caused
-     * by libvirt and should not be handled separately */
-    bool ignoreDeathEvent;
     unsigned short migrationPort;
     char *lockState;
 
