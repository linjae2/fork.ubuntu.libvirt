Description: fix possible privilege escalation via pkcheck race.
Origin: backport, based on patches provided by Daniel P. Berrange <berrange@redhat.com>

Index: libvirt-1.0.2/configure.ac
===================================================================
--- libvirt-1.0.2.orig/configure.ac	2013-09-11 12:04:37.964037621 -0400
+++ libvirt-1.0.2/configure.ac	2013-09-11 12:04:37.956037621 -0400
@@ -1118,6 +1118,14 @@
     AC_DEFINE_UNQUOTED([PKCHECK_PATH],["$PKCHECK_PATH"],[Location of pkcheck program])
     AC_DEFINE_UNQUOTED([WITH_POLKIT], 1,
         [use PolicyKit for UNIX socket access checks])
+    AC_MSG_CHECKING([whether pkcheck supports uid value])
+    pkcheck_supports_uid=$($PKG_CONFIG --variable pkcheck_supports_uid polkit-gobject-1)
+    if test "x$pkcheck_supports_uid" = "xtrue"; then
+      AC_MSG_RESULT([yes])
+      AC_DEFINE_UNQUOTED([PKCHECK_SUPPORTS_UID], 1, [Pass uid to pkcheck])
+    else
+      AC_MSG_RESULT([no])
+    fi
     AC_DEFINE_UNQUOTED([WITH_POLKIT1], 1,
         [use PolicyKit for UNIX socket access checks])
     with_polkit="yes"
Index: libvirt-1.0.2/daemon/remote.c
===================================================================
--- libvirt-1.0.2.orig/daemon/remote.c	2013-09-11 12:04:37.964037621 -0400
+++ libvirt-1.0.2/daemon/remote.c	2013-09-11 12:04:37.960037621 -0400
@@ -2372,6 +2372,7 @@
     uid_t callerUid;
     gid_t callerGid;
     pid_t callerPid;
+    unsigned long long timestamp;
 
     /* If the client is root then we want to bypass the
      * policykit auth to avoid root being denied if
@@ -2379,7 +2380,7 @@
      */
     if (auth == VIR_NET_SERVER_SERVICE_AUTH_POLKIT) {
         if (virNetServerClientGetUNIXIdentity(client, &callerUid, &callerGid,
-                                              &callerPid) < 0) {
+                                              &callerPid, &timestamp) < 0) {
             /* Don't do anything on error - it'll be validated at next
              * phase of auth anyway */
             virResetLastError();
@@ -2809,14 +2810,17 @@
     pid_t callerPid = -1;
     gid_t callerGid = -1;
     uid_t callerUid = -1;
+    unsigned long long timestamp;
     const char *action;
     int status = -1;
     char *ident = NULL;
     bool authdismissed = 0;
+    bool supportsuid = 0;
     char *pkout = NULL;
     struct daemonClientPrivate *priv =
         virNetServerClientGetPrivateData(client);
     virCommandPtr cmd = NULL;
+    static bool polkitInsecureWarned = false;
 
     virMutexLock(&priv->lock);
     action = virNetServerClientGetReadonly(client) ?
@@ -2834,7 +2838,13 @@
     }
 
     if (virNetServerClientGetUNIXIdentity(client, &callerUid, &callerGid,
-                                          &callerPid) < 0) {
+                                          &callerPid, &timestamp) < 0) {
+        goto authfail;
+    }
+
+    if (timestamp == 0) {
+        VIR_WARN("Failing polkit auth due to missing client (pid=%lld) start time",
+                 (long long)callerPid);
         goto authfail;
     }
 
@@ -2842,7 +2852,18 @@
              (long long) callerPid, callerUid);
 
     virCommandAddArg(cmd, "--process");
-    virCommandAddArgFormat(cmd, "%lld", (long long) callerPid);
+# ifdef PKCHECK_SUPPORTS_UID
+    supportsuid = 1;
+# endif
+    if (supportsuid) {
+        virCommandAddArgFormat(cmd, "%lld,%llu,%lu", (long long) callerPid, timestamp, (unsigned long) callerUid);
+    } else {
+        if (!polkitInsecureWarned) {
+            VIR_WARN("No support for caller UID with pkcheck. This deployment is known to be insecure.");
+            polkitInsecureWarned = true;
+        }
+        virCommandAddArgFormat(cmd, "%lld,%llu", (long long) callerPid, timestamp);
+    }
     virCommandAddArg(cmd, "--allow-user-interaction");
 
     if (virAsprintf(&ident, "pid:%lld,uid:%d",
Index: libvirt-1.0.2/src/locking/lock_daemon.c
===================================================================
--- libvirt-1.0.2.orig/src/locking/lock_daemon.c	2013-09-11 12:04:37.964037621 -0400
+++ libvirt-1.0.2/src/locking/lock_daemon.c	2013-09-11 12:04:37.960037621 -0400
@@ -782,6 +782,7 @@
     virLockDaemonClientPtr priv;
     uid_t clientuid;
     gid_t clientgid;
+    unsigned long long timestamp;
     bool privileged = opaque != NULL;
 
     if (VIR_ALLOC(priv) < 0) {
@@ -798,7 +799,8 @@
     if (virNetServerClientGetUNIXIdentity(client,
                                           &clientuid,
                                           &clientgid,
-                                          &priv->clientPid) < 0)
+                                          &priv->clientPid,
+                                          &timestamp) < 0)
         goto error;
 
     VIR_DEBUG("New client pid %llu uid %llu",
Index: libvirt-1.0.2/src/rpc/virnetserverclient.c
===================================================================
--- libvirt-1.0.2.orig/src/rpc/virnetserverclient.c	2013-09-11 12:04:37.964037621 -0400
+++ libvirt-1.0.2/src/rpc/virnetserverclient.c	2013-09-11 12:04:37.960037621 -0400
@@ -618,12 +618,15 @@
 }
 
 int virNetServerClientGetUNIXIdentity(virNetServerClientPtr client,
-                                      uid_t *uid, gid_t *gid, pid_t *pid)
+                                      uid_t *uid, gid_t *gid, pid_t *pid,
+                                      unsigned long long *timestamp)
 {
     int ret = -1;
     virObjectLock(client);
     if (client->sock)
-        ret = virNetSocketGetUNIXIdentity(client->sock, uid, gid, pid);
+        ret = virNetSocketGetUNIXIdentity(client->sock,
+                                          uid, gid, pid,
+                                          timestamp);
     virObjectUnlock(client);
     return ret;
 }
Index: libvirt-1.0.2/src/rpc/virnetserverclient.h
===================================================================
--- libvirt-1.0.2.orig/src/rpc/virnetserverclient.h	2013-09-11 12:04:37.964037621 -0400
+++ libvirt-1.0.2/src/rpc/virnetserverclient.h	2013-09-11 12:04:37.960037621 -0400
@@ -97,7 +97,8 @@
 const char *virNetServerClientGetIdentity(virNetServerClientPtr client);
 
 int virNetServerClientGetUNIXIdentity(virNetServerClientPtr client,
-                                      uid_t *uid, gid_t *gid, pid_t *pid);
+                                      uid_t *uid, gid_t *gid, pid_t *pid,
+                                      unsigned long long *timestamp);
 
 void *virNetServerClientGetPrivateData(virNetServerClientPtr client);
 
Index: libvirt-1.0.2/src/rpc/virnetsocket.c
===================================================================
--- libvirt-1.0.2.orig/src/rpc/virnetsocket.c	2013-09-11 12:04:37.964037621 -0400
+++ libvirt-1.0.2/src/rpc/virnetsocket.c	2013-09-11 12:04:37.960037621 -0400
@@ -1096,31 +1096,40 @@
 int virNetSocketGetUNIXIdentity(virNetSocketPtr sock,
                                 uid_t *uid,
                                 gid_t *gid,
-                                pid_t *pid)
+                                pid_t *pid,
+                                unsigned long long *timestamp)
 {
     struct ucred cr;
     socklen_t cr_len = sizeof(cr);
+    int ret = -1;
+
     virObjectLock(sock);
 
     if (getsockopt(sock->fd, SOL_SOCKET, SO_PEERCRED, &cr, &cr_len) < 0) {
         virReportSystemError(errno, "%s",
                              _("Failed to get client socket identity"));
-        virObjectUnlock(sock);
-        return -1;
+        goto cleanup;
     }
 
+    if (virProcessGetStartTime(cr.pid, timestamp) < 0)
+        goto cleanup;
+
     *pid = cr.pid;
     *uid = cr.uid;
     *gid = cr.gid;
 
+    ret = 0;
+
+cleanup:
     virObjectUnlock(sock);
-    return 0;
+    return ret;
 }
 #elif defined(LOCAL_PEERCRED)
 int virNetSocketGetUNIXIdentity(virNetSocketPtr sock,
                                 uid_t *uid,
                                 gid_t *gid,
-                                pid_t *pid)
+                                pid_t *pid,
+                                unsigned long long *timestamp ATTRIBUTE_UNUSED)
 {
     struct xucred cr;
     socklen_t cr_len = sizeof(cr);
@@ -1144,7 +1153,8 @@
 int virNetSocketGetUNIXIdentity(virNetSocketPtr sock ATTRIBUTE_UNUSED,
                                 uid_t *uid ATTRIBUTE_UNUSED,
                                 gid_t *gid ATTRIBUTE_UNUSED,
-                                pid_t *pid ATTRIBUTE_UNUSED)
+                                pid_t *pid ATTRIBUTE_UNUSED,
+                                unsigned long long *timestamp ATTRIBUTE_UNUSED)
 {
     /* XXX Many more OS support UNIX socket credentials we could port to. See dbus ....*/
     virReportSystemError(ENOSYS, "%s",
Index: libvirt-1.0.2/src/rpc/virnetsocket.h
===================================================================
--- libvirt-1.0.2.orig/src/rpc/virnetsocket.h	2013-09-11 12:04:37.964037621 -0400
+++ libvirt-1.0.2/src/rpc/virnetsocket.h	2013-09-11 12:04:37.960037621 -0400
@@ -113,7 +113,8 @@
 int virNetSocketGetUNIXIdentity(virNetSocketPtr sock,
                                 uid_t *uid,
                                 gid_t *gid,
-                                pid_t *pid);
+                                pid_t *pid,
+                                unsigned long long *timestamp);
 
 int virNetSocketSetBlocking(virNetSocketPtr sock,
                             bool blocking);
Index: libvirt-1.0.2/src/util/virprocess.c
===================================================================
--- libvirt-1.0.2.orig/src/util/virprocess.c	2013-09-11 12:04:37.964037621 -0400
+++ libvirt-1.0.2/src/util/virprocess.c	2013-09-11 15:04:17.731802621 -0400
@@ -29,12 +29,20 @@
 #include <sys/wait.h>
 #include <sched.h>
 
+#ifdef __FreeBSD__
+# include <sys/param.h>
+# include <sys/sysctl.h>
+# include <sys/user.h>
+#endif
+
+#include "viratomic.h"
 #include "virprocess.h"
 #include "virerror.h"
 #include "viralloc.h"
 #include "virfile.h"
 #include "virlog.h"
 #include "virutil.h"
+#include "virstring.h"
 
 #define VIR_FROM_THIS VIR_FROM_NONE
 
@@ -605,3 +613,110 @@
     return -1;
 }
 #endif /* ! HAVE_SETNS */
+
+#ifdef __linux__
+/*
+ * Port of code from polkitunixprocess.c under terms
+ * of the LGPLv2+
+ */
+int virProcessGetStartTime(pid_t pid,
+                           unsigned long long *timestamp)
+{
+    char *filename = NULL;
+    char *buf = NULL;
+    char *tmp;
+    int ret = -1;
+    int len;
+    char **tokens = NULL;
+
+    if (virAsprintf(&filename, "/proc/%llu/stat",
+                    (unsigned long long)pid) < 0)
+        return -1;
+
+    if ((len = virFileReadAll(filename, 1024, &buf)) < 0)
+        goto cleanup;
+
+    /* start time is the token at index 19 after the '(process name)' entry - since only this
+     * field can contain the ')' character, search backwards for this to avoid malicious
+     * processes trying to fool us
+     */
+
+    if (!(tmp = strrchr(buf, ')'))) {
+        virReportError(VIR_ERR_INTERNAL_ERROR,
+                       _("Cannot find start time in %s"),
+                       filename);
+        goto cleanup;
+    }
+    tmp += 2; /* skip ') ' */
+    if ((tmp - buf) >= len) {
+        virReportError(VIR_ERR_INTERNAL_ERROR,
+                       _("Cannot find start time in %s"),
+                       filename);
+        goto cleanup;
+    }
+
+    tokens = virStringSplit(tmp, " ", 0);
+
+    if (virStringListLength(tokens) < 20) {
+        virReportError(VIR_ERR_INTERNAL_ERROR,
+                       _("Cannot find start time in %s"),
+                       filename);
+        goto cleanup;
+    }
+
+    if (virStrToLong_ull(tokens[19],
+                         NULL,
+                         10,
+                         timestamp) < 0) {
+        virReportError(VIR_ERR_INTERNAL_ERROR,
+                       _("Cannot parse start time %s in %s"),
+                       tokens[19], filename);
+        goto cleanup;
+    }
+
+    ret = 0;
+
+cleanup:
+    virStringFreeList(tokens);
+    VIR_FREE(filename);
+    VIR_FREE(buf);
+    return ret;
+}
+#elif defined(__FreeBSD__)
+int virProcessGetStartTime(pid_t pid,
+                           unsigned long long *timestamp)
+{
+    struct kinfo_proc p;
+    int mib[4];
+    size_t len = 4;
+
+    sysctlnametomib("kern.proc.pid", mib, &len);
+
+    len = sizeof(struct kinfo_proc);
+    mib[3] = pid;
+
+    if (sysctl(mib, 4, &p, &len, NULL, 0) < 0) {
+        virReportSystemError(errno, "%s",
+                             _("Unable to query process ID start time"));
+        return -1;
+    }
+
+    *timestamp = (unsigned long long)p.ki_start.tv_sec;
+
+    return 0;
+
+}
+#else
+int virProcessGetStartTime(pid_t pid,
+                           unsigned long long *timestamp)
+{
+    static int warned = 0;
+    if (virAtomicIntInc(&warned) == 1) {
+        VIR_WARN("Process start time of pid %llu not available on this platform",
+                 (unsigned long long)pid);
+        warned = true;
+    }
+    *timestamp = 0;
+    return 0;
+}
+#endif
Index: libvirt-1.0.2/src/util/virstring.c
===================================================================
--- libvirt-1.0.2.orig/src/util/virstring.c	2013-09-11 12:04:37.964037621 -0400
+++ libvirt-1.0.2/src/util/virstring.c	2013-09-11 12:04:37.960037621 -0400
@@ -166,3 +166,14 @@
     }
     VIR_FREE(strings);
 }
+
+
+size_t virStringListLength(char **strings)
+{
+    size_t i = 0;
+
+    while (strings && strings[i])
+        i++;
+
+    return i;
+}
Index: libvirt-1.0.2/src/util/virstring.h
===================================================================
--- libvirt-1.0.2.orig/src/util/virstring.h	2013-09-11 12:04:37.964037621 -0400
+++ libvirt-1.0.2/src/util/virstring.h	2013-09-11 12:04:37.960037621 -0400
@@ -35,4 +35,6 @@
 
 void virStringFreeList(char **strings);
 
+size_t virStringListLength(char **strings);
+
 #endif /* __VIR_STRING_H__ */
Index: libvirt-1.0.2/src/util/virprocess.h
===================================================================
--- libvirt-1.0.2.orig/src/util/virprocess.h	2013-09-11 12:04:37.964037621 -0400
+++ libvirt-1.0.2/src/util/virprocess.h	2013-09-11 12:04:37.960037621 -0400
@@ -54,4 +54,7 @@
 int virProcessSetNamespaces(size_t nfdlist,
                             int *fdlist);
 
+int virProcessGetStartTime(pid_t pid,
+                           unsigned long long *timestamp);
+
 #endif /* __VIR_PROCESS_H__ */
