Description: fix possible privilege escalation via pkcheck race.
Origin: backport, based on patches provided by Daniel P. Berrange <berrange@redhat.com>

Index: libvirt-0.7.5/configure.in
===================================================================
--- libvirt-0.7.5.orig/configure.in	2013-09-12 10:18:48.717896105 -0400
+++ libvirt-0.7.5/configure.in	2013-09-12 10:18:48.705896106 -0400
@@ -717,6 +717,14 @@
     AC_DEFINE_UNQUOTED([PKCHECK_PATH],["$PKCHECK_PATH"],[Location of pkcheck program])
     AC_DEFINE_UNQUOTED([HAVE_POLKIT], 1,
         [use PolicyKit for UNIX socket access checks])
+    AC_MSG_CHECKING([whether pkcheck supports uid value])
+    pkcheck_supports_uid=$($PKG_CONFIG --variable pkcheck_supports_uid polkit-gobject-1)
+    if test "x$pkcheck_supports_uid" = "xtrue"; then
+      AC_MSG_RESULT([yes])
+      AC_DEFINE_UNQUOTED([PKCHECK_SUPPORTS_UID], 1, [Pass uid to pkcheck])
+    else
+      AC_MSG_RESULT([no])
+    fi
     AC_DEFINE_UNQUOTED([HAVE_POLKIT1], 1,
         [use PolicyKit for UNIX socket access checks])
     with_polkit="yes"
Index: libvirt-0.7.5/daemon/libvirtd.c
===================================================================
--- libvirt-0.7.5.orig/daemon/libvirtd.c	2013-09-12 10:18:48.717896105 -0400
+++ libvirt-0.7.5/daemon/libvirtd.c	2013-09-12 10:19:27.749894361 -0400
@@ -62,6 +62,7 @@
 #include "event.h"
 #include "memory.h"
 #include "stream.h"
+#include "virprocess.h"
 #ifdef HAVE_AVAHI
 #include "mdns.h"
 #endif
@@ -1239,7 +1240,7 @@
 }
 
 #if HAVE_POLKIT
-int qemudGetSocketIdentity(int fd, uid_t *uid, pid_t *pid) {
+int qemudGetSocketIdentity(int fd, uid_t *uid, pid_t *pid, unsigned long long *timestamp) {
 #ifdef SO_PEERCRED
     struct ucred cr;
     unsigned int cr_len = sizeof (cr);
@@ -1251,6 +1252,9 @@
         return -1;
     }
 
+    if (virProcessGetStartTime(cr.pid, timestamp) < 0)
+        return -1;
+
     *pid = cr.pid;
     *uid = cr.uid;
 #else
@@ -1353,8 +1357,9 @@
     if (client->auth == REMOTE_AUTH_POLKIT) {
         uid_t uid;
         pid_t pid;
+        unsigned long long timestamp;
 
-        if (qemudGetSocketIdentity(client->fd, &uid, &pid) < 0)
+        if (qemudGetSocketIdentity(client->fd, &uid, &pid, &timestamp) < 0)
             goto cleanup;
 
         /* Client is running as root, so disable auth */
Index: libvirt-0.7.5/daemon/libvirtd.h
===================================================================
--- libvirt-0.7.5.orig/daemon/libvirtd.h	2013-09-12 10:18:48.717896105 -0400
+++ libvirt-0.7.5/daemon/libvirtd.h	2013-09-12 10:18:48.705896106 -0400
@@ -306,7 +306,7 @@
 
 
 #if HAVE_POLKIT
-int qemudGetSocketIdentity(int fd, uid_t *uid, pid_t *pid);
+int qemudGetSocketIdentity(int fd, uid_t *uid, pid_t *pid, unsigned long long *timestamp);
 #endif
 
 #endif
Index: libvirt-0.7.5/daemon/remote.c
===================================================================
--- libvirt-0.7.5.orig/daemon/remote.c	2013-09-12 10:18:48.717896105 -0400
+++ libvirt-0.7.5/daemon/remote.c	2013-09-12 10:18:48.709896106 -0400
@@ -3335,10 +3335,13 @@
 {
     pid_t callerPid;
     uid_t callerUid;
+    unsigned long long timestamp;
     const char *action;
     int status = -1;
-    char pidbuf[50];
+    char pidbuf[150];
     int rv;
+    bool supportsuid = 0;
+    static bool polkitInsecureWarned = false;
 
     virMutexLock(&server->lock);
     virMutexLock(&client->lock);
@@ -3362,14 +3365,35 @@
         goto authfail;
     }
 
-    if (qemudGetSocketIdentity(client->fd, &callerUid, &callerPid) < 0) {
+    if (qemudGetSocketIdentity(client->fd, &callerUid,
+                               &callerPid, &timestamp) < 0) {
         VIR_ERROR0(_("cannot get peer socket identity"));
         goto authfail;
     }
 
+    if (timestamp == 0) {
+        VIR_WARN("Failing polkit auth due to missing client (pid=%lld) start time",
+                 (long long)callerPid);
+        goto authfail;
+     }
+
     VIR_INFO(_("Checking PID %d running as %d"), callerPid, callerUid);
 
-    rv = snprintf(pidbuf, sizeof pidbuf, "%d", callerPid);
+# ifdef PKCHECK_SUPPORTS_UID
+    supportsuid = 1;
+# endif
+    if (supportsuid) {
+        rv = snprintf(pidbuf, sizeof pidbuf, "%lld,%llu,%lu",
+                      (long long) callerPid, timestamp, (unsigned long) callerUid);
+    } else {
+        if (!polkitInsecureWarned) {
+            VIR_WARN0("No support for caller UID with pkcheck. This deployment is known to be insecure.");
+            polkitInsecureWarned = true;
+        }
+        rv = snprintf(pidbuf, sizeof pidbuf, "%lld,%llu",
+                      (long long) callerPid, timestamp);
+     }
+
     if (rv < 0 || rv >= sizeof pidbuf) {
         VIR_ERROR(_("Caller PID was too large %d"), callerPid);
         goto authfail;
@@ -3409,6 +3433,7 @@
 {
     pid_t callerPid;
     uid_t callerUid;
+    unsigned long long timestamp;
     PolKitCaller *pkcaller = NULL;
     PolKitAction *pkaction = NULL;
     PolKitContext *pkcontext = NULL;
@@ -3431,7 +3456,7 @@
         goto authfail;
     }
 
-    if (qemudGetSocketIdentity(client->fd, &callerUid, &callerPid) < 0) {
+    if (qemudGetSocketIdentity(client->fd, &callerUid, &callerPid, &timestamp) < 0) {
         VIR_ERROR0(_("cannot get peer socket identity"));
         goto authfail;
     }
Index: libvirt-0.7.5/src/Makefile.am
===================================================================
--- libvirt-0.7.5.orig/src/Makefile.am	2013-09-12 10:18:48.717896105 -0400
+++ libvirt-0.7.5/src/Makefile.am	2013-09-12 10:18:48.709896106 -0400
@@ -68,6 +68,8 @@
 		util/threads-win32.h				\
 		util/uuid.c util/uuid.h				\
 		util/util.c util/util.h				\
+		util/virprocess.h util/virprocess.c		\
+		util/virstring.h util/virstring.c		\
 		util/xml.c util/xml.h				\
 		util/virterror.c util/virterror_internal.h
 
Index: libvirt-0.7.5/src/util/virprocess.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ libvirt-0.7.5/src/util/virprocess.c	2013-09-12 10:18:48.709896106 -0400
@@ -0,0 +1,161 @@
+/*
+ * virprocess.c: interaction with processes
+ *
+ * Copyright (C) 2010-2013 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ *
+ */
+
+
+#include <config.h>
+
+#include <dirent.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <errno.h>
+#include <sys/wait.h>
+#if HAVE_SETRLIMIT
+# include <sys/time.h>
+# include <sys/resource.h>
+#endif
+#include <sched.h>
+
+#ifdef __FreeBSD__
+# include <sys/param.h>
+# include <sys/sysctl.h>
+# include <sys/user.h>
+#endif
+
+#include "virprocess.h"
+#include "virterror_internal.h"
+#include "memory.h"
+#include "util.h"
+#include "virstring.h"
+
+#define VIR_FROM_THIS VIR_FROM_NONE
+
+#define virProcessError(conn, code, fmt...)                                      \
+    virReportErrorHelper(conn, VIR_FROM_NONE, code, __FILE__,                 \
+                         __FUNCTION__, __LINE__, fmt)
+
+#ifdef __linux__
+/*
+ * Port of code from polkitunixprocess.c under terms
+ * of the LGPLv2+
+ */
+int virProcessGetStartTime(pid_t pid,
+                           unsigned long long *timestamp)
+{
+    char *filename = NULL;
+    char *buf = NULL;
+    char *tmp;
+    int ret = -1;
+    int len;
+    char **tokens = NULL;
+
+    if (virAsprintf(&filename, "/proc/%llu/stat",
+                    (unsigned long long)pid) < 0) {
+        virReportOOMError(NULL);
+        return -1;
+    }
+
+    if ((len = virFileReadAll(filename, 1024, &buf)) < 0)
+        goto cleanup;
+
+    /* start time is the token at index 19 after the '(process name)' entry - since only this
+     * field can contain the ')' character, search backwards for this to avoid malicious
+     * processes trying to fool us
+     */
+
+    if (!(tmp = strrchr(buf, ')'))) {
+        virProcessError(NULL, VIR_ERR_INTERNAL_ERROR,
+                       _("Cannot find start time in %s"),
+                       filename);
+        goto cleanup;
+    }
+    tmp += 2; /* skip ') ' */
+    if ((tmp - buf) >= len) {
+        virProcessError(NULL, VIR_ERR_INTERNAL_ERROR,
+                       _("Cannot find start time in %s"),
+                       filename);
+        goto cleanup;
+    }
+
+    tokens = virStringSplit(tmp, " ", 0);
+
+    if (virStringListLength(tokens) < 20) {
+        virProcessError(NULL, VIR_ERR_INTERNAL_ERROR,
+                       _("Cannot find start time in %s"),
+                       filename);
+        goto cleanup;
+    }
+
+    if (virStrToLong_ull(tokens[19],
+                         NULL,
+                         10,
+                         timestamp) < 0) {
+        virProcessError(NULL, VIR_ERR_INTERNAL_ERROR,
+                       _("Cannot parse start time %s in %s"),
+                       tokens[19], filename);
+        goto cleanup;
+    }
+
+    ret = 0;
+
+cleanup:
+    virStringFreeList(tokens);
+    VIR_FREE(filename);
+    VIR_FREE(buf);
+    return ret;
+}
+#elif defined(__FreeBSD__)
+int virProcessGetStartTime(pid_t pid,
+                           unsigned long long *timestamp)
+{
+    struct kinfo_proc p;
+    int mib[4];
+    size_t len = 4;
+
+    sysctlnametomib("kern.proc.pid", mib, &len);
+
+    len = sizeof(struct kinfo_proc);
+    mib[3] = pid;
+
+    if (sysctl(mib, 4, &p, &len, NULL, 0) < 0) {
+        virReportSystemError(errno, "%s",
+                             _("Unable to query process ID start time"));
+        return -1;
+    }
+
+    *timestamp = (unsigned long long)p.ki_start.tv_sec;
+
+    return 0;
+
+}
+#else
+int virProcessGetStartTime(pid_t pid,
+                           unsigned long long *timestamp)
+{
+    static int warned = 0;
+    if (virAtomicIntInc(&warned) == 1) {
+        VIR_WARN("Process start time of pid %llu not available on this platform",
+                 (unsigned long long)pid);
+        warned = true;
+    }
+    *timestamp = 0;
+    return 0;
+}
+#endif
Index: libvirt-0.7.5/src/util/virprocess.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ libvirt-0.7.5/src/util/virprocess.h	2013-09-12 10:18:48.709896106 -0400
@@ -0,0 +1,32 @@
+/*
+ * virprocess.h: interaction with processes
+ *
+ * Copyright (C) 2010-2013 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef __VIR_PROCESS_H__
+# define __VIR_PROCESS_H__
+
+# include <sys/types.h>
+
+# include "internal.h"
+
+int virProcessGetStartTime(pid_t pid,
+                           unsigned long long *timestamp);
+
+#endif /* __VIR_PROCESS_H__ */
Index: libvirt-0.7.5/src/util/virstring.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ libvirt-0.7.5/src/util/virstring.c	2013-09-12 10:18:48.709896106 -0400
@@ -0,0 +1,182 @@
+/*
+ * Copyright (C) 2012 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ *
+ * Authors:
+ *     Daniel P. Berrange <berrange@redhat.com>
+ */
+
+#include <config.h>
+
+#include <stdlib.h>
+#include <stdio.h>
+
+#include "c-ctype.h"
+#include "virstring.h"
+#include "memory.h"
+#include "buf.h"
+#include "virterror_internal.h"
+
+#define VIR_FROM_THIS VIR_FROM_NONE
+
+/*
+ * The following virStringSplit & virStringJoin methods
+ * are derived from g_strsplit / g_strjoin in glib2,
+ * also available under the LGPLv2+ license terms
+ */
+
+/**
+ * virStringSplit:
+ * @string: a string to split
+ * @delim: a string which specifies the places at which to split
+ *     the string. The delimiter is not included in any of the resulting
+ *     strings, unless @max_tokens is reached.
+ * @max_tokens: the maximum number of pieces to split @string into.
+ *     If this is 0, the string is split completely.
+ *
+ * Splits a string into a maximum of @max_tokens pieces, using the given
+ * @delim. If @max_tokens is reached, the remainder of @string is
+ * appended to the last token.
+ *
+ * As a special case, the result of splitting the empty string "" is an empty
+ * vector, not a vector containing a single string. The reason for this
+ * special case is that being able to represent a empty vector is typically
+ * more useful than consistent handling of empty elements. If you do need
+ * to represent empty elements, you'll need to check for the empty string
+ * before calling virStringSplit().
+ *
+ * Return value: a newly-allocated NULL-terminated array of strings. Use
+ *    virStringFreeList() to free it.
+ */
+char **virStringSplit(const char *string,
+                      const char *delim,
+                      size_t max_tokens)
+{
+    char **tokens = NULL;
+    size_t ntokens = 0;
+    size_t maxtokens = 0;
+    const char *remainder = string;
+    char *tmp;
+    size_t i;
+
+    if (max_tokens == 0)
+        max_tokens = INT_MAX;
+
+    tmp = strstr(remainder, delim);
+    if (tmp) {
+        size_t delimlen = strlen(delim);
+
+        while (--max_tokens && tmp) {
+            size_t len = tmp - remainder;
+
+            if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)
+                goto no_memory;
+
+            if (!(tokens[ntokens] = strndup(remainder, len)))
+                goto no_memory;
+            ntokens++;
+            remainder = tmp + delimlen;
+            tmp = strstr(remainder, delim);
+        }
+    }
+    if (*string) {
+        if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)
+            goto no_memory;
+
+        if (!(tokens[ntokens] = strdup(remainder)))
+            goto no_memory;
+        ntokens++;
+    }
+
+    if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)
+        goto no_memory;
+    tokens[ntokens++] = NULL;
+
+    return tokens;
+
+no_memory:
+    virReportOOMError(NULL);
+    for (i = 0 ; i < ntokens ; i++)
+        VIR_FREE(tokens[i]);
+    VIR_FREE(tokens);
+    return NULL;
+}
+
+
+/**
+ * virStringJoin:
+ * @strings: a NULL-terminated array of strings to join
+ * @delim: a string to insert between each of the strings
+ *
+ * Joins a number of strings together to form one long string, with the
+ * @delim inserted between each of them. The returned string
+ * should be freed with VIR_FREE().
+ *
+ * Returns: a newly-allocated string containing all of the strings joined
+ *     together, with @delim between them
+ */
+char *virStringJoin(const char **strings,
+                    const char *delim)
+{
+    char *ret;
+    virBuffer buf = VIR_BUFFER_INITIALIZER;
+    while (*strings) {
+        virBufferAdd(&buf, *strings, -1);
+        if (*(strings+1))
+            virBufferAdd(&buf, delim, -1);
+        strings++;
+    }
+    if (virBufferError(&buf)) {
+        virReportOOMError(NULL);
+        return NULL;
+    }
+    ret = virBufferContentAndReset(&buf);
+    if (!ret) {
+        if (!(ret = strdup(""))) {
+            virReportOOMError(NULL);
+            return NULL;
+        }
+    }
+    return ret;
+}
+
+
+/**
+ * virStringFreeList:
+ * @str_array: a NULL-terminated array of strings to free
+ *
+ * Frees a NULL-terminated array of strings, and the array itself.
+ * If called on a NULL value, virStringFreeList() simply returns.
+ */
+void virStringFreeList(char **strings)
+{
+    char **tmp = strings;
+    while (tmp && *tmp) {
+        VIR_FREE(*tmp);
+        tmp++;
+    }
+    VIR_FREE(strings);
+}
+
+size_t virStringListLength(char **strings)
+{
+    size_t i = 0;
+
+    while (strings && strings[i])
+        i++;
+
+    return i;
+}
Index: libvirt-0.7.5/src/util/virstring.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ libvirt-0.7.5/src/util/virstring.h	2013-09-12 10:18:48.709896106 -0400
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2007-2012 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ *
+ * Authors:
+ *     Daniel P. Berrange <berrange@redhat.com>
+ */
+
+#ifndef __VIR_STRING_H__
+# define __VIR_STRING_H__
+
+# include <stdarg.h>
+
+# include "internal.h"
+
+char **virStringSplit(const char *string,
+                      const char *delim,
+                      size_t max_tokens)
+    ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2);
+
+char *virStringJoin(const char **strings,
+                    const char *delim);
+
+void virStringFreeList(char **strings);
+
+size_t virStringListLength(char **strings);
+
+#endif /* __VIR_STRING_H__ */
Index: libvirt-0.7.5/src/util/memory.h
===================================================================
--- libvirt-0.7.5.orig/src/util/memory.h	2013-09-12 10:18:48.717896105 -0400
+++ libvirt-0.7.5/src/util/memory.h	2013-09-12 10:18:48.709896106 -0400
@@ -48,6 +48,10 @@
 int virAlloc(void *ptrptr, size_t size) ATTRIBUTE_RETURN_CHECK;
 int virAllocN(void *ptrptr, size_t size, size_t count) ATTRIBUTE_RETURN_CHECK;
 int virReallocN(void *ptrptr, size_t size, size_t count) ATTRIBUTE_RETURN_CHECK;
+int virExpandN(void *ptrptr, size_t size, size_t *count,
+               size_t add) ATTRIBUTE_RETURN_CHECK;
+int virResizeN(void *ptrptr, size_t size, size_t *alloc, size_t count,
+               size_t desired) ATTRIBUTE_RETURN_CHECK;
 void virFree(void *ptrptr);
 
 /**
@@ -89,6 +93,29 @@
 #define VIR_REALLOC_N(ptr, count) virReallocN(&(ptr), sizeof(*(ptr)), (count))
 
 /**
+ * VIR_RESIZE_N:
+ * @ptr: pointer to hold address of allocated memory
+ * @alloc: variable tracking number of elements currently allocated
+ * @count: number of elements currently in use
+ * @add: minimum number of elements to additionally support
+ *
+ * Blindly using VIR_EXPAND_N(array, alloc, 1) in a loop scales
+ * quadratically, because every iteration must copy contents from
+ * all prior iterations.  But amortized linear scaling can be achieved
+ * by tracking allocation size separately from the number of used
+ * elements, and growing geometrically only as needed.
+ *
+ * If 'count' + 'add' is larger than 'alloc', then geometrically reallocate
+ * the array of 'alloc' elements, each sizeof(*ptr) bytes long, and store
+ * the address of allocated memory in 'ptr' and the new size in 'alloc'.
+ * The new elements are filled with zero.
+ *
+ * Returns -1 on failure, 0 on success
+ */
+# define VIR_RESIZE_N(ptr, alloc, count, add) \
+    virResizeN(&(ptr), sizeof(*(ptr)), &(alloc), count, add)
+
+/**
  * VIR_FREE:
  * @ptr: pointer holding address to be freed
  *
Index: libvirt-0.7.5/src/util/memory.c
===================================================================
--- libvirt-0.7.5.orig/src/util/memory.c	2013-09-12 10:18:48.717896105 -0400
+++ libvirt-0.7.5/src/util/memory.c	2013-09-12 10:18:48.713896105 -0400
@@ -165,6 +165,72 @@
 }
 
 /**
+ * virExpandN:
+ * @ptrptr: pointer to pointer for address of allocated memory
+ * @size: number of bytes per element
+ * @countptr: pointer to number of elements in array
+ * @add: number of elements to add
+ *
+ * Resize the block of memory in 'ptrptr' to be an array of
+ * '*countptr' + 'add' elements, each 'size' bytes in length.
+ * Update 'ptrptr' and 'countptr'  with the details of the newly
+ * allocated memory. On failure, 'ptrptr' and 'countptr' are not
+ * changed. Any newly allocated memory in 'ptrptr' is zero-filled.
+ *
+ * Returns -1 on failure to allocate, zero on success
+ */
+int virExpandN(void *ptrptr, size_t size, size_t *countptr, size_t add)
+{
+    int ret;
+
+    if (*countptr + add < *countptr) {
+        errno = ENOMEM;
+        return -1;
+    }
+    ret = virReallocN(ptrptr, size, *countptr + add);
+    if (ret == 0) {
+        memset(*(char **)ptrptr + (size * *countptr), 0, size * add);
+        *countptr += add;
+    }
+    return ret;
+}
+
+/**
+ * virResizeN:
+ * @ptrptr: pointer to pointer for address of allocated memory
+ * @size: number of bytes per element
+ * @allocptr: pointer to number of elements allocated in array
+ * @count: number of elements currently used in array
+ * @add: minimum number of additional elements to support in array
+ *
+ * If 'count' + 'add' is larger than '*allocptr', then resize the
+ * block of memory in 'ptrptr' to be an array of at least 'count' +
+ * 'add' elements, each 'size' bytes in length. Update 'ptrptr' and
+ * 'allocptr' with the details of the newly allocated memory. On
+ * failure, 'ptrptr' and 'allocptr' are not changed. Any newly
+ * allocated memory in 'ptrptr' is zero-filled.
+ *
+ * Returns -1 on failure to allocate, zero on success
+ */
+int virResizeN(void *ptrptr, size_t size, size_t *allocptr, size_t count,
+               size_t add)
+{
+    size_t delta;
+
+    if (count + add < count) {
+        errno = ENOMEM;
+        return -1;
+    }
+    if (count + add <= *allocptr)
+        return 0;
+
+    delta = count + add - *allocptr;
+    if (delta < *allocptr / 2)
+        delta = *allocptr / 2;
+    return virExpandN(ptrptr, size, allocptr, delta);
+}
+
+/**
  * virFree:
  * @ptrptr: pointer to pointer for address of memory to be freed
  *
