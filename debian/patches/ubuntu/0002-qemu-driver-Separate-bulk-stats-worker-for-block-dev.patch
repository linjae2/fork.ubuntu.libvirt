From 96cc5154e85f2718011fed7c40c66182fd7cfdee Mon Sep 17 00:00:00 2001
From: Peter Krempa <pkrempa@redhat.com>
Date: Wed, 18 May 2016 14:40:10 +0200
Subject: [PATCH 2/3] qemu: driver: Separate bulk stats worker for block
 devices

Extract the fallback path that reloads the stats from disk into a
separate function.
---
 src/qemu/qemu_driver.c | 58 ++++++++++++++++++++++++++++++++------------------
 1 file changed, 37 insertions(+), 21 deletions(-)

Bug: upstream, https://libvirt.org/git/?p=libvirt.git;a=commit;h=3aa5d51a9530a8737ca584b393c29297dd9bbc37
Bug-Ubuntu: https://bugs.launchpad.net/bugs/1746630
Bug-Redhat: https://bugzilla.redhat.com/show_bug.cgi?id=1337073
Index: libvirt-1.3.1/src/qemu/qemu_driver.c
===================================================================
--- libvirt-1.3.1.orig/src/qemu/qemu_driver.c	2017-11-21 20:19:37.490770968 -0800
+++ libvirt-1.3.1/src/qemu/qemu_driver.c	2018-01-31 16:37:59.000000000 -0800
@@ -19227,6 +19227,40 @@
         goto cleanup; \
 } while (0)
 
+/* refresh information by opening images on the disk */
+static int
+qemuDomainGetStatsOneBlockFallback(virQEMUDriverPtr driver,
+                                   virQEMUDriverConfigPtr cfg,
+                                   virDomainObjPtr dom,
+                                   virDomainStatsRecordPtr record,
+                                   int *maxparams,
+                                   virStorageSourcePtr src,
+                                   size_t block_idx)
+{
+    int ret = -1;
+
+    if (virStorageSourceIsEmpty(src))
+        return 0;
+
+    if (qemuStorageLimitsRefresh(driver, cfg, dom, src) < 0) {
+        virResetLastError();
+        return 0;
+    }
+
+    if (src->allocation)
+        QEMU_ADD_BLOCK_PARAM_ULL(record, maxparams, block_idx,
+                                 "allocation", src->allocation);
+    if (src->capacity)
+        QEMU_ADD_BLOCK_PARAM_ULL(record, maxparams, block_idx,
+                                 "capacity", src->capacity);
+    if (src->physical)
+        QEMU_ADD_BLOCK_PARAM_ULL(record, maxparams, block_idx,
+                                 "physical", src->physical);
+    ret = 0;
+ cleanup:
+    return ret;
+}
+
 
 static int
 qemuDomainGetStatsOneBlock(virQEMUDriverPtr driver,
@@ -19256,28 +19290,10 @@
         QEMU_ADD_BLOCK_PARAM_UI(record, maxparams, block_idx, "backingIndex",
                                 backing_idx);
 
+    /* use fallback path if data is not available */
     if (!stats || !alias || !(entry = virHashLookup(stats, alias))) {
-        if (virStorageSourceIsEmpty(src)) {
-            ret = 0;
-            goto cleanup;
-        }
-
-        if (qemuStorageLimitsRefresh(driver, cfg, dom, src) < 0) {
-            virResetLastError();
-            ret = 0;
-            goto cleanup;
-        }
-
-        if (src->allocation)
-            QEMU_ADD_BLOCK_PARAM_ULL(record, maxparams, block_idx,
-                                     "allocation", src->allocation);
-        if (src->capacity)
-            QEMU_ADD_BLOCK_PARAM_ULL(record, maxparams, block_idx,
-                                     "capacity", src->capacity);
-        if (src->physical)
-            QEMU_ADD_BLOCK_PARAM_ULL(record, maxparams, block_idx,
-                                     "physical", src->physical);
-        ret = 0;
+        ret = qemuDomainGetStatsOneBlockFallback(driver, cfg, dom, record,
+                                                 maxparams, src, block_idx);
         goto cleanup;
     }
 
