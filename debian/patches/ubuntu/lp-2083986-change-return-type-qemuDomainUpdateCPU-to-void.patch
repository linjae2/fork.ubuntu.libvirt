From: Jiri Denemark <jdenemar@redhat.com>
Date: Wed, 17 Apr 2024 14:24:38 +0200
Subject: qemu: Change return type of qemuDomainUpdateCPU to void

The function never fails.

Signed-off-by: Jiri Denemark <jdenemar@redhat.com>
Reviewed-by: Peter Krempa <pkrempa@redhat.com>

Origin: https://gitlab.com/libvirt/libvirt/-/commit/efac33bfaa86d4f7fe20bc7fe2c1395d380ccb62
Bug-RHEL: https://issues.redhat.com/browse/RHEL-30622
Bug-Ubuntu: https://bugs.launchpad.net/ubuntu/+source/libvirt/+bug/2083986
---
 src/qemu/qemu_domain.c  | 12 ++++--------
 src/qemu/qemu_domain.h  |  2 +-
 src/qemu/qemu_process.c |  8 +++-----
 3 files changed, 8 insertions(+), 14 deletions(-)

diff --git a/src/qemu/qemu_domain.c b/src/qemu/qemu_domain.c
index 08e51d6..8c05067 100644
--- a/src/qemu/qemu_domain.c
+++ b/src/qemu/qemu_domain.c
@@ -10884,10 +10884,8 @@ virSaveCookieCallbacks virQEMUDriverDomainSaveCookie = {
  * for. The domain definition will either contain a copy of the original CPU
  * definition or a copy of @cpu in case the domain was already running and
  * we're just restoring a saved state or preparing for incoming migration.
- *
- * Returns 0 on success, -1 on error.
  */
-int
+void
 qemuDomainUpdateCPU(virDomainObj *vm,
                     virCPUDef *cpu,
                     virCPUDef **origCPU)
@@ -10897,14 +10895,14 @@ qemuDomainUpdateCPU(virDomainObj *vm,
     *origCPU = NULL;
 
     if (!vm->def->cpu)
-        return 0;
+        return;
 
     if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_QUERY_CPU_MODEL_EXPANSION))
-        return 0;
+        return;
 
     /* nothing to do if only topology part of CPU def is used */
     if (vm->def->cpu->mode == VIR_CPU_MODE_CUSTOM && !vm->def->cpu->model)
-        return 0;
+        return;
 
     VIR_DEBUG("Replacing CPU definition");
 
@@ -10914,8 +10912,6 @@ qemuDomainUpdateCPU(virDomainObj *vm,
         vm->def->cpu = virCPUDefCopy(cpu);
     else
         vm->def->cpu = virCPUDefCopy(*origCPU);
-
-    return 0;
 }
 
 
diff --git a/src/qemu/qemu_domain.h b/src/qemu/qemu_domain.h
index 2d424ca..4da31cc 100644
--- a/src/qemu/qemu_domain.h
+++ b/src/qemu/qemu_domain.h
@@ -974,7 +974,7 @@ virStorageSource *qemuDomainGetStorageSourceByDevstr(const char *devstr,
                                                        virDomainDef *def,
                                                        virDomainBackupDef *backupdef);
 
-int
+void
 qemuDomainUpdateCPU(virDomainObj *vm,
                     virCPUDef *cpu,
                     virCPUDef **origCPU);
diff --git a/src/qemu/qemu_process.c b/src/qemu/qemu_process.c
index b75599d..1dd173d 100644
--- a/src/qemu/qemu_process.c
+++ b/src/qemu/qemu_process.c
@@ -5640,8 +5640,7 @@ qemuProcessInit(virQEMUDriver *driver,
     if (qemuProcessPrepareQEMUCaps(vm, driver->qemuCapsCache) < 0)
         goto cleanup;
 
-    if (qemuDomainUpdateCPU(vm, updatedCPU, &origCPU) < 0)
-        goto cleanup;
+    qemuDomainUpdateCPU(vm, updatedCPU, &origCPU);
 
     if (qemuProcessStartValidate(driver, vm, priv->qemuCaps, flags) < 0)
         goto cleanup;
@@ -9135,9 +9134,8 @@ qemuProcessReconnect(void *opaque)
     qemuDomainVcpuPersistOrder(obj->def);
 
     /* Make sure the original CPU is always preserved in priv->origCPU. */
-    if (!priv->origCPU &&
-        qemuDomainUpdateCPU(obj, NULL, &priv->origCPU) < 0)
-        goto error;
+    if (!priv->origCPU)
+        qemuDomainUpdateCPU(obj, NULL, &priv->origCPU);
 
     if (qemuProcessRefreshCPU(driver, obj) < 0)
         goto error;
