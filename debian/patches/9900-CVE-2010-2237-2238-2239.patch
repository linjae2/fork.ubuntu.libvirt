Description: fix for the following CVEs:
 CVE-2010-2237: ignoring defined main disk format when looking up disk backing
  stores
 CVE-2010-2238: ignoring defined disk backing store format when recursing into
  disk image backing stores
 CVE-2010-2239: not setting user defined backing store format when creating new
  image

 Summary of changes (from upstream commits):
  * When QEMU opens a backing store for a QCow2 file, it will
    normally auto-probe for the format of the backing store,
    rather than assuming it has the same format as the referencing
    file. There is a QCow2 extension that allows an explicit format
    for the backing store to be embedded in the referencing file.
    This closes the auto-probing security hole in QEMU. This backing store
    format can be useful for libvirt users of virStorageFileGetMetadata, so
    extract this data and report it. Callers of virStorageFileGetMeta need to
    be told of the backing store format. If no format is declared,
    they can make a decision whether to allow format probing or
    not.
  * Instead of including a field in FileTypeInfo struct for the
    disk format, rely on the array index matching the format.
    Use verify() to assert the correct number of elements in the
    array.
  * The virStorageFileGetMetadataFromFD did two jobs in one. First
    it probed for storage type, then it extracted metadata for the
    type. It is desirable to be able to separate these jobs, allowing
    probing without querying metadata, and querying metadata without
    probing.
  * Require the disk image to be passed into virStorageFileGetMetadata.
    If this is set to VIR_STORAGE_FILE_AUTO, then the format will be
    resolved using probing. This makes it easier to control when
    probing will be used
  * There is duplicated code which iterates over disk backing stores
    performing some action. Provide a convenient helper for doing
    this to eliminate duplication & risk of mistakes with disk format
    probing
  * Update the SELinux and AppArmor security drivers over to use the shared
    helper API virDomainDiskDefForeachPath().
  * Adjust security driver params
  * Disk format probing is now disabled by default. A new config
    option in /etc/qemu/qemu.conf will re-enable it for existing
    deployments where this causes trouble
  * Record a default driver name/type in capabilities struct. Use this
    when parsing disks if value is not set in XML config.
  * When creating qcow2 files with a backing store, it is important
    to set an explicit format to prevent QEMU probing. The storage
    backend was only doing this if it found a 'kvm-img' binary. This
    is wrong because plenty of kvm-img binaries don't support an
    explicit format, and plenty of 'qemu-img' binaries do support
    a format. The result was that most qcow2 files were not getting
    a backing store format.

Origin: (sometimes heavily) adapted from upstream git:
 7b91c43bef0348c8cc18037bec5aef668b51fc90
 66c633413960e869a15062cee8667db51e6c817a
 f8d3e740cee4903bd2eef1a072e8190f5e9e92b9
 7b2c30d0af7938df533b85e948918cfdff2e5f01
 494b96317334716f846436a5ec485963411cb4a3
 e2ebe4b785eccb930f36f400a22940fa9660a24b
 38d7c5a26e4c12a784619f1ed4fc993d9af82032
 e7db25186de8cb278f2b5f5c51e965129defaa11
 f087f0656f882be305783e24d55921b57fbbcb97
 6883117e3c6a6cabd760b6e6a468b69ad7b02839
 8c145200e7fe410cb4fb99b3bbce17fba4a680ca
 8f86eaca4900b9788bf7d877770ac15adf948738
 d01340e796fd86328ed1ecb1788bdaa0b48c8743
 adde0e2cf60f8ad558de40361d9306e5da8ca9ab
 05c9a413364d5ab94117bbd3ae281ad0748d7fbb

Index: libvirt-0.7.5/src/util/storage_file.c
===================================================================
--- libvirt-0.7.5.orig/src/util/storage_file.c	2010-09-01 09:42:05.000000000 -0500
+++ libvirt-0.7.5/src/util/storage_file.c	2010-09-01 09:42:12.000000000 -0500
@@ -50,7 +50,6 @@
 
 /* Either 'magic' or 'extension' *must* be provided */
 struct FileTypeInfo {
-    int type;           /* One of the constants above */
     const char *magic;  /* Optional string of file magic
                          * to check at head of file */
     const char *extension; /* Optional file extension to check */
@@ -70,82 +69,86 @@
     int qcowCryptOffset;  /* Byte offset from start of file
                            * where to find encryption mode,
                            * -1 if encryption is not used */
-    int (*getBackingStore)(virConnectPtr conn, char **res,
+    int (*getBackingStore)(virConnectPtr conn, char **res, int *format,
                            const unsigned char *buf, size_t buf_size);
 };
 
-static int cowGetBackingStore(virConnectPtr, char **,
+static int cowGetBackingStore(virConnectPtr, char **, int *,
                               const unsigned char *, size_t);
-static int qcowXGetBackingStore(virConnectPtr, char **,
+static int qcow1GetBackingStore(virConnectPtr, char **, int *,
                                 const unsigned char *, size_t);
-static int vmdk4GetBackingStore(virConnectPtr, char **,
+static int qcow2GetBackingStore(virConnectPtr, char **, int *,
+                                const unsigned char *, size_t);
+static int vmdk4GetBackingStore(virConnectPtr, char **, int *,
                                 const unsigned char *, size_t);
 
 
 static struct FileTypeInfo const fileTypeInfo[] = {
-    /* Bochs */
-    /* XXX Untested
-    { VIR_STORAGE_FILE_BOCHS, "Bochs Virtual HD Image", NULL,
-      LV_LITTLE_ENDIAN, 64, 0x20000,
-      32+16+16+4+4+4+4+4, 8, 1, -1, NULL },*/
-    /* CLoop */
-    /* XXX Untested
-    { VIR_STORAGE_VOL_CLOOP, "#!/bin/sh\n#V2.0 Format\nmodprobe cloop file=$0 && mount -r -t iso9660 /dev/cloop $1\n", NULL,
-      LV_LITTLE_ENDIAN, -1, 0,
-      -1, 0, 0, -1, NULL }, */
-    /* Cow */
-    { VIR_STORAGE_FILE_COW, "OOOM", NULL,
-      LV_BIG_ENDIAN, 4, 2,
-      4+4+1024+4, 8, 1, -1, cowGetBackingStore },
-    /* DMG */
-    /* XXX QEMU says there's no magic for dmg, but we should check... */
-    { VIR_STORAGE_FILE_DMG, NULL, ".dmg",
-      0, -1, 0,
-      -1, 0, 0, -1, NULL },
-    /* XXX there's probably some magic for iso we can validate too... */
-    { VIR_STORAGE_FILE_ISO, NULL, ".iso",
-      0, -1, 0,
-      -1, 0, 0, -1, NULL },
-    /* Parallels */
-    /* XXX Untested
-    { VIR_STORAGE_FILE_PARALLELS, "WithoutFreeSpace", NULL,
-      LV_LITTLE_ENDIAN, 16, 2,
-      16+4+4+4+4, 4, 512, -1, NULL },
-    */
-    /* QCow */
-    { VIR_STORAGE_FILE_QCOW, "QFI", NULL,
-      LV_BIG_ENDIAN, 4, 1,
-      4+4+8+4+4, 8, 1, 4+4+8+4+4+8+1+1+2, qcowXGetBackingStore },
-    /* QCow 2 */
-    { VIR_STORAGE_FILE_QCOW2, "QFI", NULL,
-      LV_BIG_ENDIAN, 4, 2,
-      4+4+8+4+4, 8, 1, 4+4+8+4+4+8, qcowXGetBackingStore },
-    /* VMDK 3 */
-    /* XXX Untested
-    { VIR_STORAGE_FILE_VMDK, "COWD", NULL,
-      LV_LITTLE_ENDIAN, 4, 1,
-      4+4+4, 4, 512, -1, NULL },
-    */
-    /* VMDK 4 */
-    { VIR_STORAGE_FILE_VMDK, "KDMV", NULL,
-      LV_LITTLE_ENDIAN, 4, 1,
-      4+4+4, 8, 512, -1, vmdk4GetBackingStore },
-    /* Connectix / VirtualPC */
-    /* XXX Untested
-    { VIR_STORAGE_FILE_VPC, "conectix", NULL,
-      LV_BIG_ENDIAN, -1, 0,
-      -1, 0, 0, -1, NULL},
-    */
+    [VIR_STORAGE_FILE_RAW] = { NULL, NULL, LV_LITTLE_ENDIAN, -1, 0, 0, 0, 0, 0, NULL },
+    [VIR_STORAGE_FILE_DIR] = { NULL, NULL, LV_LITTLE_ENDIAN, -1, 0, 0, 0, 0, 0, NULL },
+    [VIR_STORAGE_FILE_BOCHS] = {
+        /*"Bochs Virtual HD Image", */ /* Untested */ NULL,
+        NULL,
+        LV_LITTLE_ENDIAN, 64, 0x20000,
+        32+16+16+4+4+4+4+4, 8, 1, -1, NULL
+    },
+    [VIR_STORAGE_FILE_CLOOP] = {
+        /*"#!/bin/sh\n#V2.0 Format\nmodprobe cloop file=$0 && mount -r -t iso9660 /dev/cloop $1\n", */ /* Untested */ NULL,
+        NULL,
+        LV_LITTLE_ENDIAN, -1, 0,
+        -1, 0, 0, -1, NULL
+    },
+    [VIR_STORAGE_FILE_COW] = {
+        "OOOM", NULL,
+        LV_BIG_ENDIAN, 4, 2,
+        4+4+1024+4, 8, 1, -1, cowGetBackingStore
+    },
+    [VIR_STORAGE_FILE_DMG] = {
+        NULL, /* XXX QEMU says there's no magic for dmg, but we should check... */
+        ".dmg",
+        0, -1, 0,
+        -1, 0, 0, -1, NULL
+    },
+    [VIR_STORAGE_FILE_ISO] = {
+        NULL, /* XXX there's probably some magic for iso we can validate too... */
+        ".iso",
+        0, -1, 0,
+        -1, 0, 0, -1, NULL
+    },
+    [VIR_STORAGE_FILE_QCOW] = {
+        "QFI", NULL,
+        LV_BIG_ENDIAN, 4, 1,
+        4+4+8+4+4, 8, 1, 4+4+8+4+4+8+1+1+2, qcow1GetBackingStore
+    },
+    [VIR_STORAGE_FILE_QCOW2] = {
+        "QFI", NULL,
+        LV_BIG_ENDIAN, 4, 2,
+        4+4+8+4+4, 8, 1, 4+4+8+4+4+8, qcow2GetBackingStore
+    },
+    [VIR_STORAGE_FILE_VMDK] = {
+        "KDMV", NULL,
+        LV_LITTLE_ENDIAN, 4, 1,
+        4+4+4, 8, 512, -1, vmdk4GetBackingStore
+    },
+    [VIR_STORAGE_FILE_VPC] = {
+        "conectix", NULL,
+        LV_BIG_ENDIAN, 12, 0x10000,
+        8 + 4 + 4 + 8 + 4 + 4 + 2 + 2 + 4, 8, 1, -1, NULL
+    },
 };
+verify(ARRAY_CARDINALITY(fileTypeInfo) == VIR_STORAGE_FILE_LAST);
 
 static int
 cowGetBackingStore(virConnectPtr conn,
                    char **res,
+                   int *format,
                    const unsigned char *buf,
                    size_t buf_size)
 {
 #define COW_FILENAME_MAXLEN 1024
     *res = NULL;
+    *format = VIR_STORAGE_FILE_AUTO;
+
     if (buf_size < 4+4+ COW_FILENAME_MAXLEN)
         return BACKING_STORE_INVALID;
     if (buf[4+4] == '\0') /* cow_header_v2.backing_file[0] */
@@ -159,32 +162,100 @@
     return BACKING_STORE_OK;
 }
 
+
+#define QCOWX_HDR_BACKING_FILE_OFFSET 4+4
+#define QCOWX_HDR_BACKING_FILE_SIZE 4+4+8
+
+#define QCOW2_HDR_TOTAL_SIZE 4+4+8+4+4+8+4+4+8+8+4+4+8
+#define QCOW2_HDR_EXTENSION_END 0
+#define QCOW2_HDR_EXTENSION_BACKING_FORMAT 0xE2792ACA
+
+static int
+qcow2GetBackingStoreFormat(int *format,
+                           const unsigned char *buf,
+                           size_t buf_size,
+                           size_t extension_start,
+                           size_t extension_end)
+{
+    size_t offset = extension_start;
+
+    /*
+     * The extensions take format of
+     *
+     * int32: magic
+     * int32: length
+     * byte[length]: payload
+     *
+     * Unknown extensions can be ignored by skipping
+     * over "length" bytes in the data stream.
+     */
+    while (offset < (buf_size-8) &&
+           offset < (extension_end-8)) {
+        int magic = (buf[offset] << 24) +
+            (buf[offset+1] << 16) +
+            (buf[offset+2] << 8) +
+            (buf[offset+3]);
+        int len = (buf[offset+4] << 24) +
+            (buf[offset+5] << 16) +
+            (buf[offset+6] << 8) +
+            (buf[offset+7]);
+
+        offset += 8;
+        if ((offset + len) > buf_size)
+            break;
+
+        switch (magic) {
+        case QCOW2_HDR_EXTENSION_END:
+            goto done;
+
+        case QCOW2_HDR_EXTENSION_BACKING_FORMAT:
+            if (buf[offset+len] != '\0')
+                break;
+            *format = virStorageFileFormatTypeFromString(
+                ((const char *)buf)+offset);
+            break;
+        }
+
+        offset += len;
+    }
+
+done:
+
+    return 0;
+}
+
+
 static int
 qcowXGetBackingStore(virConnectPtr conn,
                      char **res,
+                     int *format,
                      const unsigned char *buf,
-                     size_t buf_size)
+                     size_t buf_size,
+                     bool isQCow2)
 {
     unsigned long long offset;
     unsigned long size;
 
     *res = NULL;
-    if (buf_size < 4+4+8+4)
+    if (format)
+        *format = VIR_STORAGE_FILE_AUTO;
+
+    if (buf_size < QCOWX_HDR_BACKING_FILE_OFFSET+8+4)
         return BACKING_STORE_INVALID;
-    offset = (((unsigned long long)buf[4+4] << 56)
-              | ((unsigned long long)buf[4+4+1] << 48)
-              | ((unsigned long long)buf[4+4+2] << 40)
-              | ((unsigned long long)buf[4+4+3] << 32)
-              | ((unsigned long long)buf[4+4+4] << 24)
-              | ((unsigned long long)buf[4+4+5] << 16)
-              | ((unsigned long long)buf[4+4+6] << 8)
-              | buf[4+4+7]); /* QCowHeader.backing_file_offset */
+    offset = (((unsigned long long)buf[QCOWX_HDR_BACKING_FILE_OFFSET] << 56)
+              | ((unsigned long long)buf[QCOWX_HDR_BACKING_FILE_OFFSET+1] << 48)
+              | ((unsigned long long)buf[QCOWX_HDR_BACKING_FILE_OFFSET+2] << 40)
+              | ((unsigned long long)buf[QCOWX_HDR_BACKING_FILE_OFFSET+3] << 32)
+              | ((unsigned long long)buf[QCOWX_HDR_BACKING_FILE_OFFSET+4] << 24)
+              | ((unsigned long long)buf[QCOWX_HDR_BACKING_FILE_OFFSET+5] << 16)
+              | ((unsigned long long)buf[QCOWX_HDR_BACKING_FILE_OFFSET+6] << 8)
+              | buf[QCOWX_HDR_BACKING_FILE_OFFSET+7]); /* QCowHeader.backing_file_offset */
     if (offset > buf_size)
         return BACKING_STORE_INVALID;
-    size = ((buf[4+4+8] << 24)
-            | (buf[4+4+8+1] << 16)
-            | (buf[4+4+8+2] << 8)
-            | buf[4+4+8+3]); /* QCowHeader.backing_file_size */
+    size = ((buf[QCOWX_HDR_BACKING_FILE_SIZE] << 24)
+            | (buf[QCOWX_HDR_BACKING_FILE_SIZE+1] << 16)
+            | (buf[QCOWX_HDR_BACKING_FILE_SIZE+2] << 8)
+            | buf[QCOWX_HDR_BACKING_FILE_SIZE+3]); /* QCowHeader.backing_file_size */
     if (size == 0)
         return BACKING_STORE_OK;
     if (offset + size > buf_size || offset + size < offset)
@@ -197,13 +268,66 @@
     }
     memcpy(*res, buf + offset, size);
     (*res)[size] = '\0';
+
+    /*
+     * Traditionally QCow2 files had a layout of
+     *
+     * [header]
+     * [backingStoreName]
+     *
+     * Although the backingStoreName typically followed
+     * the header immediately, this was not required by
+     * the format. By specifying a higher byte offset for
+     * the backing file offset in the header, it was
+     * possible to leave space between the header and
+     * start of backingStore.
+     *
+     * This hack is now used to store extensions to the
+     * qcow2 format:
+     *
+     * [header]
+     * [extensions]
+     * [backingStoreName]
+     *
+     * Thus the file region to search for extensions is
+     * between the end of the header (QCOW2_HDR_TOTAL_SIZE)
+     * and the start of the backingStoreName (offset)
+     */
+    if (isQCow2)
+        qcow2GetBackingStoreFormat(format, buf, buf_size, QCOW2_HDR_TOTAL_SIZE, offset);
+
     return BACKING_STORE_OK;
 }
 
 
 static int
+qcow1GetBackingStore(virConnectPtr conn,
+                     char **res,
+                     int *format,
+                     const unsigned char *buf,
+                     size_t buf_size)
+{
+    /* QCow1 doesn't have the extensions capability
+     * used to store backing format */
+    *format = VIR_STORAGE_FILE_AUTO;
+    return qcowXGetBackingStore(conn, res, NULL, buf, buf_size, false);
+}
+
+static int
+qcow2GetBackingStore(virConnectPtr conn,
+                     char **res,
+                     int *format,
+                     const unsigned char *buf,
+                     size_t buf_size)
+{
+    return qcowXGetBackingStore(conn, res, format, buf, buf_size, true);
+}
+
+
+static int
 vmdk4GetBackingStore(virConnectPtr conn,
                      char **res,
+                     int *format,
                      const unsigned char *buf,
                      size_t buf_size)
 {
@@ -213,6 +337,12 @@
     size_t len;
 
     *res = NULL;
+    /* XXX should we set VMDK instead ?  QEMU does auto
+     * probing, but this isn't in compliance with the
+     * VMDK spec/VMWare impl which presumes only VMDK
+     * backing format
+     */
+    *format = VIR_STORAGE_FILE_AUTO;
 
     if (buf_size <= 0x200)
         return BACKING_STORE_INVALID;
@@ -269,144 +399,319 @@
     return res;
 }
 
-/**
- * Probe the header of a file to determine what type of disk image
- * it is, and info about its capacity if available.
- */
-int
-virStorageFileGetMetadataFromFD(virConnectPtr conn,
-                                const char *path,
-                                int fd,
-                                virStorageFileMetadata *meta)
+
+static int
+virStorageFileMatchesMagic(int format,
+                           unsigned char *buf,
+                           size_t buflen)
 {
-    unsigned char head[20*512]; /* vmdk4GetBackingStore needs this much. */
-    int len, i;
+    int mlen;
 
-    /* If all else fails, call it a raw file */
-    meta->format = VIR_STORAGE_FILE_RAW;
+    if (fileTypeInfo[format].magic == NULL)
+        return 0;
 
-    if ((len = read(fd, head, sizeof(head))) < 0) {
-        virReportSystemError(conn, errno, _("cannot read header '%s'"), path);
-        return -1;
+    /* Validate magic data */
+    mlen = strlen(fileTypeInfo[format].magic);
+    if (mlen > buflen)
+        return 0;
+
+    if (memcmp(buf, fileTypeInfo[format].magic, mlen) != 0)
+        return 0;
+
+    return 1;
+}
+
+
+static int
+virStorageFileMatchesExtension(int format,
+                               const char *path)
+{
+    if (fileTypeInfo[format].extension == NULL)
+        return 0;
+
+    if (virFileHasSuffix(path, fileTypeInfo[format].extension))
+        return 1;
+
+    return 0;
+}
+
+
+static int
+virStorageFileMatchesVersion(int format,
+                             unsigned char *buf,
+                             size_t buflen)
+{
+    int version;
+
+    /* Validate version number info */
+    if (fileTypeInfo[format].versionOffset == -1)
+        return 0;
+
+    if ((fileTypeInfo[format].versionOffset + 4) > buflen)
+        return 0;
+
+    if (fileTypeInfo[format].endian == LV_LITTLE_ENDIAN) {
+        version =
+            (buf[fileTypeInfo[format].versionOffset+3] << 24) |
+            (buf[fileTypeInfo[format].versionOffset+2] << 16) |
+            (buf[fileTypeInfo[format].versionOffset+1] << 8) |
+            (buf[fileTypeInfo[format].versionOffset]);
+    } else {
+        version =
+            (buf[fileTypeInfo[format].versionOffset] << 24) |
+            (buf[fileTypeInfo[format].versionOffset+1] << 16) |
+            (buf[fileTypeInfo[format].versionOffset+2] << 8) |
+            (buf[fileTypeInfo[format].versionOffset+3]);
     }
+    if (version != fileTypeInfo[format].versionNumber)
+        return 0;
 
-    /* First check file magic */
-    for (i = 0 ; i < ARRAY_CARDINALITY(fileTypeInfo) ; i++) {
-        int mlen;
+    return 1;
+}
 
-        if (fileTypeInfo[i].magic == NULL)
-            continue;
 
-        /* Validate magic data */
-        mlen = strlen(fileTypeInfo[i].magic);
-        if (mlen > len)
-            continue;
-        if (memcmp(head, fileTypeInfo[i].magic, mlen) != 0)
-            continue;
-
-        /* Validate version number info */
-        if (fileTypeInfo[i].versionNumber != -1) {
-            int version;
-
-            if (fileTypeInfo[i].endian == LV_LITTLE_ENDIAN) {
-                version = (head[fileTypeInfo[i].versionOffset+3] << 24) |
-                    (head[fileTypeInfo[i].versionOffset+2] << 16) |
-                    (head[fileTypeInfo[i].versionOffset+1] << 8) |
-                    head[fileTypeInfo[i].versionOffset];
-            } else {
-                version = (head[fileTypeInfo[i].versionOffset] << 24) |
-                    (head[fileTypeInfo[i].versionOffset+1] << 16) |
-                    (head[fileTypeInfo[i].versionOffset+2] << 8) |
-                    head[fileTypeInfo[i].versionOffset+3];
-            }
-            if (version != fileTypeInfo[i].versionNumber)
-                continue;
-        }
+static int
+virStorageFileGetMetadataFromBuf(virConnectPtr conn,
+                                 int format,
+                                 const char *path,
+                                 unsigned char *buf,
+                                 size_t buflen,
+                                 virStorageFileMetadata *meta)
+{
+    /* XXX we should consider moving virStorageBackendUpdateVolInfo
+     * code into this method, for non-magic files
+     */
+    if (!fileTypeInfo[format].magic) {
+        return 0;
+    }
 
-        /* Optionally extract capacity from file */
-        if (fileTypeInfo[i].sizeOffset != -1) {
-            if (fileTypeInfo[i].endian == LV_LITTLE_ENDIAN) {
-                meta->capacity =
-                    ((unsigned long long)head[fileTypeInfo[i].sizeOffset+7] << 56) |
-                    ((unsigned long long)head[fileTypeInfo[i].sizeOffset+6] << 48) |
-                    ((unsigned long long)head[fileTypeInfo[i].sizeOffset+5] << 40) |
-                    ((unsigned long long)head[fileTypeInfo[i].sizeOffset+4] << 32) |
-                    ((unsigned long long)head[fileTypeInfo[i].sizeOffset+3] << 24) |
-                    ((unsigned long long)head[fileTypeInfo[i].sizeOffset+2] << 16) |
-                    ((unsigned long long)head[fileTypeInfo[i].sizeOffset+1] << 8) |
-                    ((unsigned long long)head[fileTypeInfo[i].sizeOffset]);
-            } else {
-                meta->capacity =
-                    ((unsigned long long)head[fileTypeInfo[i].sizeOffset] << 56) |
-                    ((unsigned long long)head[fileTypeInfo[i].sizeOffset+1] << 48) |
-                    ((unsigned long long)head[fileTypeInfo[i].sizeOffset+2] << 40) |
-                    ((unsigned long long)head[fileTypeInfo[i].sizeOffset+3] << 32) |
-                    ((unsigned long long)head[fileTypeInfo[i].sizeOffset+4] << 24) |
-                    ((unsigned long long)head[fileTypeInfo[i].sizeOffset+5] << 16) |
-                    ((unsigned long long)head[fileTypeInfo[i].sizeOffset+6] << 8) |
-                    ((unsigned long long)head[fileTypeInfo[i].sizeOffset+7]);
-            }
-            /* Avoid unlikely, but theoretically possible overflow */
-            if (meta->capacity > (ULLONG_MAX / fileTypeInfo[i].sizeMultiplier))
-                continue;
-            meta->capacity *= fileTypeInfo[i].sizeMultiplier;
+    /* Optionally extract capacity from file */
+    if (fileTypeInfo[format].sizeOffset != -1) {
+        if ((fileTypeInfo[format].sizeOffset + 8) > buflen)
+            return 1;
+
+        if (fileTypeInfo[format].endian == LV_LITTLE_ENDIAN) {
+            meta->capacity =
+                ((unsigned long long)buf[fileTypeInfo[format].sizeOffset+7] << 56) |
+                ((unsigned long long)buf[fileTypeInfo[format].sizeOffset+6] << 48) |
+                ((unsigned long long)buf[fileTypeInfo[format].sizeOffset+5] << 40) |
+                ((unsigned long long)buf[fileTypeInfo[format].sizeOffset+4] << 32) |
+                ((unsigned long long)buf[fileTypeInfo[format].sizeOffset+3] << 24) |
+                ((unsigned long long)buf[fileTypeInfo[format].sizeOffset+2] << 16) |
+                ((unsigned long long)buf[fileTypeInfo[format].sizeOffset+1] << 8) |
+                ((unsigned long long)buf[fileTypeInfo[format].sizeOffset]);
+        } else {
+            meta->capacity =
+                ((unsigned long long)buf[fileTypeInfo[format].sizeOffset] << 56) |
+                ((unsigned long long)buf[fileTypeInfo[format].sizeOffset+1] << 48) |
+                ((unsigned long long)buf[fileTypeInfo[format].sizeOffset+2] << 40) |
+                ((unsigned long long)buf[fileTypeInfo[format].sizeOffset+3] << 32) |
+                ((unsigned long long)buf[fileTypeInfo[format].sizeOffset+4] << 24) |
+                ((unsigned long long)buf[fileTypeInfo[format].sizeOffset+5] << 16) |
+                ((unsigned long long)buf[fileTypeInfo[format].sizeOffset+6] << 8) |
+                ((unsigned long long)buf[fileTypeInfo[format].sizeOffset+7]);
         }
+        /* Avoid unlikely, but theoretically possible overflow */
+        if (meta->capacity > (ULLONG_MAX / fileTypeInfo[format].sizeMultiplier))
+            return 1;
+        meta->capacity *= fileTypeInfo[format].sizeMultiplier;
+    }
+
+    if (fileTypeInfo[format].qcowCryptOffset != -1) {
+        int crypt_format;
 
-        if (fileTypeInfo[i].qcowCryptOffset != -1) {
-            int crypt_format;
+        crypt_format =
+            (buf[fileTypeInfo[format].qcowCryptOffset] << 24) |
+            (buf[fileTypeInfo[format].qcowCryptOffset+1] << 16) |
+            (buf[fileTypeInfo[format].qcowCryptOffset+2] << 8) |
+            (buf[fileTypeInfo[format].qcowCryptOffset+3]);
+        meta->encrypted = crypt_format != 0;
+    }
 
-            crypt_format = (head[fileTypeInfo[i].qcowCryptOffset] << 24) |
-                (head[fileTypeInfo[i].qcowCryptOffset+1] << 16) |
-                (head[fileTypeInfo[i].qcowCryptOffset+2] << 8) |
-                head[fileTypeInfo[i].qcowCryptOffset+3];
-            meta->encrypted = crypt_format != 0;
+    if (fileTypeInfo[format].getBackingStore != NULL) {
+        char *backing;
+        int backingFormat;
+        int ret = fileTypeInfo[format].getBackingStore(conn, &backing,
+                                                       &backingFormat,
+                                                       buf, buflen);
+        if (ret == BACKING_STORE_INVALID)
+            return 1;
+
+        if (ret == BACKING_STORE_ERROR)
+            return -1;
+
+        if (backing != NULL) {
+            meta->backingStore = absolutePathFromBaseFile(path, backing);
+            VIR_FREE(backing);
+            if (meta->backingStore == NULL) {
+                virReportOOMError(NULL);
+                return -1;
+            }
+            meta->backingStoreFormat = backingFormat;
+        } else {
+            meta->backingStore = NULL;
+            meta->backingStoreFormat = VIR_STORAGE_FILE_AUTO;
         }
+    }
 
-        /* Validation passed, we know the file format now */
-        meta->format = fileTypeInfo[i].type;
-        if (fileTypeInfo[i].getBackingStore != NULL) {
-            char *base;
+    return 0;
+}
 
-            switch (fileTypeInfo[i].getBackingStore(conn, &base, head, len)) {
-            case BACKING_STORE_OK:
-                break;
 
-            case BACKING_STORE_INVALID:
-                continue;
+static int
+virStorageFileProbeFormatFromBuf(const char *path,
+                                 unsigned char *buf,
+                                 size_t buflen)
+{
+    int format = VIR_STORAGE_FILE_RAW;
+    int i;
 
-            case BACKING_STORE_ERROR:
-                return -1;
-            }
-            if (base != NULL) {
-                meta->backingStore = absolutePathFromBaseFile(path, base);
-                VIR_FREE(base);
-                if (meta->backingStore == NULL) {
-                    virReportOOMError(conn);
-                    return -1;
-                }
-            }
+    /* First check file magic */
+    for (i = 0 ; i < VIR_STORAGE_FILE_LAST ; i++) {
+        if (virStorageFileMatchesMagic(i, buf, buflen) &&
+            virStorageFileMatchesVersion(i, buf, buflen)) {
+            format = i;
+            goto cleanup;
         }
-        return 0;
     }
 
     /* No magic, so check file extension */
-    for (i = 0 ; i < ARRAY_CARDINALITY(fileTypeInfo) ; i++) {
-        if (fileTypeInfo[i].extension == NULL)
-            continue;
+    for (i = 0 ; i < VIR_STORAGE_FILE_LAST ; i++) {
+        if (virStorageFileMatchesExtension(i, path)) {
+            format = i;
+            goto cleanup;
+        }
+    }
 
-        if (!virFileHasSuffix(path, fileTypeInfo[i].extension))
-            continue;
+cleanup:
+    return format;
+}
 
-        meta->format = fileTypeInfo[i].type;
-        return 0;
+
+/**
+ * virStorageFileProbeFormatFromFD:
+ *
+ * Probe for the format of 'fd' (which is an open file descriptor
+ * pointing to 'path'), returning the detected disk format.
+ *
+ * Callers are advised never to trust the returned 'format'
+ * unless it is listed as VIR_STORAGE_FILE_RAW, since a
+ * malicious guest can turn a file into any other non-raw
+ * format at will.
+ *
+ * Best option: Don't use this function
+ */
+
+int
+virStorageFileProbeFormatFromFD(virConnectPtr conn, const char *path, int fd)
+{
+    unsigned char head[20*512]; /* vmdk4GetBackingStore needs this much. */
+    int len;
+
+    if (lseek(fd, 0, SEEK_SET) == (off_t)-1) {
+        virReportSystemError(conn, errno, _("cannot set to start of '%s'"), path);
+        return -1;
     }
 
-    return 0;
+     if ((len = read(fd, head, sizeof(head))) < 0) {
+         virReportSystemError(conn, errno, _("cannot read header '%s'"), path);
+         return -1;
+     }
+
+    return virStorageFileProbeFormatFromBuf(path, head, len);
 }
 
+/**
+ * virStorageFileProbeFormat:
+ *
+ * Probe for the format of 'path', returning the detected
+ * disk format.
+ *
+ * Callers are advised never to trust the returned 'format'
+ * unless it is listed as VIR_STORAGE_FILE_RAW, since a
+ * malicious guest can turn a file into any other non-raw
+ * format at will.
+ *
+ * Best option: Don't use this function
+ */
+int
+virStorageFileProbeFormat(virConnectPtr conn, const char *path)
+{
+    int fd, ret;
+
+    if ((fd = open(path, O_RDONLY)) < 0) {
+        virReportSystemError(conn, errno, _("cannot open file '%s'"), path);
+        return -1;
+    }
+
+    ret = virStorageFileProbeFormatFromFD(conn, path, fd);
+
+    close(fd);
+
+    return ret;
+}
+
+/**
+ * virStorageFileGetMetadataFromFD:
+ *
+ * Probe for the format of 'fd' (which is an open file descriptor
+ * for the file 'path'), filling 'meta' with the detected
+ * format and other associated metadata.
+ *
+ * Callers are advised never to trust the returned 'meta->format'
+ * unless it is listed as VIR_STORAGE_FILE_RAW, since a
+ * malicious guest can turn a file into any other non-raw
+ * format at will.
+ */
+int
+virStorageFileGetMetadataFromFD(virConnectPtr conn,
+                                const char *path,
+                                int fd,
+                                int format,
+                                virStorageFileMetadata *meta)
+{
+    unsigned char head[20*512]; /* vmdk4GetBackingStore needs this much. */
+    int len;
+
+    memset(meta, 0, sizeof (*meta));
+
+    if (lseek(fd, 0, SEEK_SET) == (off_t)-1) {
+        virReportSystemError(conn, errno, _("cannot set to start of '%s'"), path);
+        return -1;
+    }
+
+    if ((len = read(fd, head, sizeof(head))) < 0) {
+        virReportSystemError(conn, errno, _("cannot read header '%s'"), path);
+        return -1;
+    }
+
+    if (format == VIR_STORAGE_FILE_AUTO)
+        format = virStorageFileProbeFormatFromBuf(path, head, len);
+
+    if (format < 0 ||
+        format >= VIR_STORAGE_FILE_LAST) {
+        virReportSystemError(conn, EINVAL, _("unknown storage file format %d"), format);
+        return -1;
+    }
+
+    return virStorageFileGetMetadataFromBuf(conn, format, path, head, len, meta);
+}
+
+/**
+ * virStorageFileGetMetadata:
+ *
+ * Probe for the format of 'path', filling 'meta' with the detected
+ * format and other associated metadata.
+ *
+ * Callers are advised never to trust the returned 'meta->format'
+ * unless it is listed as VIR_STORAGE_FILE_RAW, since a
+ * malicious guest can turn a file into any other non-raw
+ * format at will.
+ */
 int
 virStorageFileGetMetadata(virConnectPtr conn,
                           const char *path,
+                          int format,
                           virStorageFileMetadata *meta)
 {
     int fd, ret;
@@ -416,7 +721,7 @@
         return -1;
     }
 
-    ret = virStorageFileGetMetadataFromFD(conn, path, fd, meta);
+    ret = virStorageFileGetMetadataFromFD(conn, path, fd, format, meta);
 
     close(fd);
 
Index: libvirt-0.7.5/src/util/storage_file.h
===================================================================
--- libvirt-0.7.5.orig/src/util/storage_file.h	2010-09-01 09:42:05.000000000 -0500
+++ libvirt-0.7.5/src/util/storage_file.h	2010-09-01 09:42:12.000000000 -0500
@@ -28,6 +28,7 @@
 #include <stdbool.h>
 
 enum virStorageFileFormat {
+    VIR_STORAGE_FILE_AUTO = -1,
     VIR_STORAGE_FILE_RAW = 0,
     VIR_STORAGE_FILE_DIR,
     VIR_STORAGE_FILE_BOCHS,
@@ -45,18 +46,25 @@
 VIR_ENUM_DECL(virStorageFileFormat);
 
 typedef struct _virStorageFileMetadata {
-    int format;
     char *backingStore;
+    int backingStoreFormat;
     unsigned long long capacity;
     bool encrypted;
 } virStorageFileMetadata;
 
+int virStorageFileProbeFormat(virConnectPtr conn, const char *path);
+int virStorageFileProbeFormatFromFD(virConnectPtr conn,
+                                    const char *path,
+                                    int fd);
+
 int virStorageFileGetMetadata(virConnectPtr conn,
                               const char *path,
+                              int format,
                               virStorageFileMetadata *meta);
 int virStorageFileGetMetadataFromFD(virConnectPtr conn,
                                     const char *path,
                                     int fd,
+                                    int format,
                                     virStorageFileMetadata *meta);
 
 #endif /* __VIR_STORAGE_FILE_H__ */
Index: libvirt-0.7.5/src/libvirt_private.syms
===================================================================
--- libvirt-0.7.5.orig/src/libvirt_private.syms	2010-09-01 09:42:05.000000000 -0500
+++ libvirt-0.7.5/src/libvirt_private.syms	2010-09-01 09:42:12.000000000 -0500
@@ -174,6 +174,7 @@
 virDomainObjListDeinit;
 virDomainObjRef;
 virDomainObjUnref;
+virDomainDiskDefForeachPath;
 
 
 # domain_event.h
@@ -460,6 +461,7 @@
 virSecurityDriverInit;
 virSecurityDriverSetDOI;
 virSecurityDriverGetDOI;
+virSecurityDriverGetAllowDiskFormatProbing;
 virSecurityDriverGetModel;
 
 
@@ -507,6 +509,8 @@
 # storage_file.h
 virStorageFileFormatTypeToString;
 virStorageFileFormatTypeFromString;
+virStorageFileProbeFormat;
+virStorageFileProbeFormatFromFD;
 virStorageFileGetMetadata;
 virStorageFileGetMetadataFromFD;
 
Index: libvirt-0.7.5/src/qemu/qemu_driver.c
===================================================================
--- libvirt-0.7.5.orig/src/qemu/qemu_driver.c	2010-09-01 09:42:12.000000000 -0500
+++ libvirt-0.7.5/src/qemu/qemu_driver.c	2010-09-01 09:42:12.000000000 -0500
@@ -851,7 +851,9 @@
     if (obj->def->seclabel.type == VIR_DOMAIN_SECLABEL_DYNAMIC &&
         driver->securityDriver &&
         driver->securityDriver->domainReserveSecurityLabel &&
-        driver->securityDriver->domainReserveSecurityLabel(NULL, obj) < 0)
+        driver->securityDriver->domainReserveSecurityLabel(NULL,
+                                                           driver->securityDriver,
+                                                           obj) < 0)
         goto error;
 
     if (obj->def->id >= driver->nextvmid)
@@ -891,7 +893,8 @@
     virSecurityDriverPtr security_drv;
 
     ret = virSecurityDriverStartup(&security_drv,
-                                   qemud_drv->securityDriverName);
+                                   qemud_drv->securityDriverName,
+                                   qemud_drv->allowDiskFormatProbing);
     if (ret == -1) {
         VIR_ERROR0(_("Failed to start security driver"));
         return -1;
@@ -921,6 +924,14 @@
         return NULL;
     }
 
+    if (secDriver && virSecurityDriverGetAllowDiskFormatProbing(secDriver)) {
+        caps->defaultDiskDriverName = NULL;
+        caps->defaultDiskDriverType = NULL;
+    } else {
+        caps->defaultDiskDriverName = "qemu";
+        caps->defaultDiskDriverType = "raw";
+    }
+
     /* Domain XML parser hooks */
     caps->privateDataAllocFunc = qemuDomainObjPrivateAlloc;
     caps->privateDataFreeFunc = qemuDomainObjPrivateFree;
@@ -2391,7 +2402,9 @@
     if (vm->def->seclabel.type == VIR_DOMAIN_SECLABEL_DYNAMIC &&
         driver->securityDriver &&
         driver->securityDriver->domainGenSecurityLabel &&
-        driver->securityDriver->domainGenSecurityLabel(conn, vm) < 0)
+        driver->securityDriver->domainGenSecurityLabel(conn,
+                                                       driver->securityDriver,
+                                                       vm) < 0)
         return -1;
 
     /* Ensure no historical cgroup for this VM is lieing around bogus settings */
@@ -3736,7 +3749,9 @@
 
     if (driver->securityDriver &&
         driver->securityDriver->domainSetSavedStateLabel &&
-        driver->securityDriver->domainSetSavedStateLabel(dom->conn, vm, path) == -1)
+        driver->securityDriver->domainSetSavedStateLabel(dom->conn,
+                                                         driver->securityDriver,
+                                                         vm, path) == -1)
         goto endjob;
 
     if (header.compressed == QEMUD_SAVE_FORMAT_RAW) {
@@ -3771,7 +3786,9 @@
 
     if (driver->securityDriver &&
         driver->securityDriver->domainRestoreSavedStateLabel &&
-        driver->securityDriver->domainRestoreSavedStateLabel(dom->conn, path) == -1)
+        driver->securityDriver->domainRestoreSavedStateLabel(dom->conn,
+                                                             driver->securityDriver,
+                                                             path) == -1)
         goto endjob;
 
     ret = 0;
@@ -3866,7 +3883,9 @@
 
     if (driver->securityDriver &&
         driver->securityDriver->domainSetSavedStateLabel &&
-        driver->securityDriver->domainSetSavedStateLabel(dom->conn, vm, path) == -1)
+        driver->securityDriver->domainSetSavedStateLabel(dom->conn,
+                                                         driver->securityDriver,
+                                                         vm, path) == -1)
         goto endjob;
 
     /* Migrate will always stop the VM, so the resume condition is
@@ -3901,7 +3920,9 @@
 
     if (driver->securityDriver &&
         driver->securityDriver->domainRestoreSavedStateLabel &&
-        driver->securityDriver->domainRestoreSavedStateLabel(dom->conn, path) == -1)
+        driver->securityDriver->domainRestoreSavedStateLabel(dom->conn,
+                                                             driver->securityDriver,
+                                                             path) == -1)
         goto endjob;
 
 endjob:
@@ -5386,7 +5408,9 @@
     if (qemuDomainSetDeviceOwnership(conn, driver, dev, 0) < 0)
         return -1;
     if (driver->securityDriver &&
-        driver->securityDriver->domainSetSecurityHostdevLabel(conn, vm, dev->data.hostdev) < 0)
+        driver->securityDriver->domainSetSecurityHostdevLabel(conn,
+                                                              driver->securityDriver,
+                                                              vm, dev->data.hostdev) < 0)
         return -1;
 
     switch (hostdev->source.subsys.type) {
@@ -5463,7 +5487,9 @@
         case VIR_DOMAIN_DISK_DEVICE_CDROM:
         case VIR_DOMAIN_DISK_DEVICE_FLOPPY:
             if (driver->securityDriver)
-                driver->securityDriver->domainSetSecurityImageLabel(dom->conn, vm, dev->data.disk);
+                driver->securityDriver->domainSetSecurityImageLabel(dom->conn,
+                                                                    driver->securityDriver,
+                                                                    vm, dev->data.disk);
 
             if (qemuDomainSetDeviceOwnership(dom->conn, driver, dev, 0) < 0)
                 goto endjob;
@@ -5473,7 +5499,9 @@
 
         case VIR_DOMAIN_DISK_DEVICE_DISK:
             if (driver->securityDriver)
-                driver->securityDriver->domainSetSecurityImageLabel(dom->conn, vm, dev->data.disk);
+                driver->securityDriver->domainSetSecurityImageLabel(dom->conn,
+                                                                    driver->securityDriver,
+                                                                    vm, dev->data.disk);
 
             if (qemuDomainSetDeviceOwnership(dom->conn, driver, dev, 0) < 0)
                 goto endjob;
@@ -5789,7 +5817,9 @@
     }
 
     if (driver->securityDriver &&
-        driver->securityDriver->domainSetSecurityHostdevLabel(conn, vm, dev->data.hostdev) < 0)
+        driver->securityDriver->domainSetSecurityHostdevLabel(conn,
+                                                              driver->securityDriver,
+                                                              vm, dev->data.hostdev) < 0)
         VIR_WARN0("Failed to restore device labelling");
 
     if (qemuDomainSetDeviceOwnership(conn, driver, dev, 1) < 0)
@@ -5836,7 +5866,9 @@
          dev->data.disk->bus == VIR_DOMAIN_DISK_BUS_VIRTIO)) {
         ret = qemudDomainDetachPciDiskDevice(dom->conn, driver, vm, dev);
         if (driver->securityDriver)
-            driver->securityDriver->domainRestoreSecurityImageLabel(dom->conn, vm, dev->data.disk);
+            driver->securityDriver->domainRestoreSecurityImageLabel(dom->conn,
+                                                                    driver->securityDriver,
+                                                                    vm, dev->data.disk);
         if (qemuDomainSetDeviceOwnership(dom->conn, driver, dev, 1) < 0)
             VIR_WARN0("Fail to restore disk device ownership");
     } else if (dev->type == VIR_DOMAIN_DEVICE_NET) {
Index: libvirt-0.7.5/src/security/security_selinux.c
===================================================================
--- libvirt-0.7.5.orig/src/security/security_selinux.c	2010-09-01 09:42:11.000000000 -0500
+++ libvirt-0.7.5/src/security/security_selinux.c	2010-09-01 09:42:12.000000000 -0500
@@ -157,6 +157,7 @@
 
 static int
 SELinuxGenSecurityLabel(virConnectPtr conn,
+                        virSecurityDriverPtr drv ATTRIBUTE_UNUSED,
                         virDomainObjPtr vm)
 {
     int rc = -1;
@@ -219,6 +220,7 @@
 
 static int
 SELinuxReserveSecurityLabel(virConnectPtr conn,
+                            virSecurityDriverPtr drv ATTRIBUTE_UNUSED,
                             virDomainObjPtr vm)
 {
     security_context_t pctx;
@@ -260,13 +262,15 @@
 }
 
 static int
-SELinuxSecurityDriverOpen(virConnectPtr conn, virSecurityDriverPtr drv)
+SELinuxSecurityDriverOpen(virConnectPtr conn ATTRIBUTE_UNUSED,
+                          virSecurityDriverPtr drv,
+                          bool allowDiskFormatProbing)
 {
     /*
      * Where will the DOI come from?  SELinux configuration, or qemu
      * configuration? For the moment, we'll just set it to "0".
      */
-    virSecurityDriverSetDOI(conn, drv, SECURITY_SELINUX_VOID_DOI);
+    virSecurityDriverSetAllowDiskFormatProbing(drv, allowDiskFormatProbing);
     return SELinuxInitialize(conn);
 }
 
@@ -376,6 +380,7 @@
 
 static int
 SELinuxRestoreSecurityImageLabel(virConnectPtr conn,
+                                 virSecurityDriverPtr drv ATTRIBUTE_UNUSED,
                                  virDomainObjPtr vm ATTRIBUTE_UNUSED,
                                  virDomainDiskDefPtr disk)
 {
@@ -397,52 +402,45 @@
 }
 
 static int
+SELinuxSetSecurityFileLabel(virDomainDiskDefPtr disk,
+                            const char *path,
+                            unsigned int depth,
+                            void *opaque)
+{
+    const virSecurityLabelDefPtr secdef = opaque;
+
+    if (depth == 0) {
+        if (disk->shared) {
+            return SELinuxSetFilecon(path, default_image_context);
+        } else if (disk->readonly) {
+            return SELinuxSetFilecon(path, default_content_context);
+        } else if (secdef->imagelabel) {
+            return SELinuxSetFilecon(path, secdef->imagelabel);
+        } else {
+            return 0;
+        }
+    } else {
+        return SELinuxSetFilecon(path, default_content_context);
+    }
+}
+
+static int
 SELinuxSetSecurityImageLabel(virConnectPtr conn,
+                             virSecurityDriverPtr drv,
                              virDomainObjPtr vm,
                              virDomainDiskDefPtr disk)
 
 {
     const virSecurityLabelDefPtr secdef = &vm->def->seclabel;
-    const char *path;
-
-    if (!disk->src)
-        return 0;
-
-    path = disk->src;
-    do {
-        virStorageFileMetadata meta;
-        int ret;
+    bool allowDiskFormatProbing = virSecurityDriverGetAllowDiskFormatProbing(drv);
 
-        memset(&meta, 0, sizeof(meta));
-
-        ret = virStorageFileGetMetadata(conn, path, &meta);
-
-        if (path != disk->src)
-            VIR_FREE(path);
-        path = NULL;
-
-        if (ret < 0)
-            return -1;
-
-        if (meta.backingStore != NULL &&
-            SELinuxSetFilecon(conn, meta.backingStore,
-                              default_content_context) < 0) {
-            VIR_FREE(meta.backingStore);
-            return -1;
-        }
-
-        path = meta.backingStore;
-    } while (path != NULL);
-
-    if (disk->shared) {
-        return SELinuxSetFilecon(conn, disk->src, default_image_context);
-    } else if (disk->readonly) {
-        return SELinuxSetFilecon(conn, disk->src, default_content_context);
-    } else if (secdef->imagelabel) {
-        return SELinuxSetFilecon(conn, disk->src, secdef->imagelabel);
-    }
-
-    return 0;
+    return virDomainDiskDefForeachPath(conn,
+                                       disk,
+                                       true,
+                                       allowDiskFormatProbing,
+                                       false,
+                                       (virDomainDiskDefPathIterator) SELinuxSetSecurityFileLabel,
+                                       secdef);
 }
 
 
@@ -470,6 +468,7 @@
 
 static int
 SELinuxSetSecurityHostdevLabel(virConnectPtr conn,
+                               virSecurityDriverPtr drv ATTRIBUTE_UNUSED,
                                virDomainObjPtr vm,
                                virDomainHostdevDefPtr dev)
 
@@ -541,6 +540,7 @@
 
 static int
 SELinuxRestoreSecurityHostdevLabel(virConnectPtr conn,
+                                   virSecurityDriverPtr drv ATTRIBUTE_UNUSED,
                                    virDomainHostdevDefPtr dev)
 
 {
@@ -626,6 +626,7 @@
 
 static int
 SELinuxSetSavedStateLabel(virConnectPtr conn,
+                          virSecurityDriverPtr drv ATTRIBUTE_UNUSED,
                           virDomainObjPtr vm,
                           const char *savefile)
 {
@@ -637,6 +638,7 @@
 
 static int
 SELinuxRestoreSavedStateLabel(virConnectPtr conn,
+                              virSecurityDriverPtr drv ATTRIBUTE_UNUSED,
                               const char *savefile)
 {
     return SELinuxRestoreSecurityFileLabel(conn, savefile);
Index: libvirt-0.7.5/src/security/virt-aa-helper.c
===================================================================
--- libvirt-0.7.5.orig/src/security/virt-aa-helper.c	2010-09-01 09:42:12.000000000 -0500
+++ libvirt-0.7.5/src/security/virt-aa-helper.c	2010-09-01 09:51:39.000000000 -0500
@@ -36,11 +36,11 @@
 #include "uuid.h"
 #include "hostusb.h"
 #include "pci.h"
-#include "storage_file.h"
 
 static char *progname;
 
 typedef struct {
+    bool allowDiskFormatProbing;
     char uuid[PROFILE_NAME_SIZE];       /* UUID of vm */
     bool dryrun;                /* dry run */
     char cmd;                   /* 'c'   create
@@ -803,6 +803,31 @@
 }
 
 static int
+add_file_path(virDomainDiskDefPtr disk,
+              const char *path,
+              size_t depth,
+              void *opaque)
+{
+    virBufferPtr buf = opaque;
+    int ret;
+
+    if (depth == 0) {
+        if (disk->readonly)
+            ret = vah_add_file(buf, path, "r");
+        else
+            ret = vah_add_file(buf, path, "rw");
+    } else {
+        ret = vah_add_file(buf, path, "r");
+    }
+
+    if (ret != 0)
+        ret = -1;
+
+    return ret;
+}
+
+
+static int
 get_files(vahControl * ctl)
 {
     virBuffer buf = VIR_BUFFER_INITIALIZER;
@@ -823,45 +848,19 @@
         goto clean;
     }
 
-    for (i = 0; i < ctl->def->ndisks; i++)
-        if (ctl->def->disks[i] && ctl->def->disks[i]->src) {
-            int ret;
-            const char *path;
-
-            path = ctl->def->disks[i]->src;
-            do {
-                virStorageFileMetadata meta;
-
-                memset(&meta, 0, sizeof(meta));
-
-                ret = virStorageFileGetMetadata(NULL, path, &meta);
-
-                if (path != ctl->def->disks[i]->src)
-                    VIR_FREE(path);
-                path = NULL;
-
-                if (ret < 0) {
-                    vah_warning("could not open path, skipping");
-                    continue;
-                }
-
-                if (meta.backingStore != NULL &&
-                    (ret = vah_add_file(&buf, meta.backingStore, "rw")) != 0) {
-                    VIR_FREE(meta.backingStore);
-                    goto clean;
-                }
-
-                path = meta.backingStore;
-            } while (path != NULL);
-
-            if (ctl->def->disks[i]->readonly)
-                ret = vah_add_file(&buf, ctl->def->disks[i]->src, "r");
-            else
-                ret = vah_add_file(&buf, ctl->def->disks[i]->src, "rw");
-
-            if (ret != 0)
-                goto clean;
-        }
+    for (i = 0; i < ctl->def->ndisks; i++) {
+        /* XXX passing ignoreOpenFailure = true to get back to the behavior
+         * from before using virDomainDiskDefForeachPath. actually we should
+         * be passing ignoreOpenFailure = false and handle open errors more
+         * careful than just ignoring them */
+        int ret = virDomainDiskDefForeachPath(NULL, ctl->def->disks[i],
+                                              ctl->allowDiskFormatProbing,
+                                              true,
+                                              (virDomainDiskDefPathIterator) add_file_path,
+                                              &buf);
+        if (ret != 0)
+            goto clean;
+    }
 
     for (i = 0; i < ctl->def->nserials; i++)
         if (ctl->def->serials[i] && ctl->def->serials[i]->data.file.path)
@@ -922,7 +921,10 @@
                 if (pci == NULL)
                     continue;
 
-                rc = pciDeviceFileIterate(NULL, pci, file_iterate_pci_cb, &buf);
+                rc = pciDeviceFileIterate(NULL,
+                                          pci,
+                                          (pciDeviceFileActor) file_iterate_pci_cb,
+                                          &buf);
                 pciFreeDevice(NULL, pci);
 
                 break;
@@ -957,6 +959,7 @@
 {
     int arg, idx = 0;
     struct option opt[] = {
+        {"probing", 1, 0, 'p' },
         {"add", 0, 0, 'a'},
         {"create", 0, 0, 'c'},
         {"dryrun", 0, 0, 'd'},
@@ -969,7 +972,7 @@
         {0, 0, 0, 0}
     };
 
-    while ((arg = getopt_long(argc, argv, "acdDhrRH:b:u:f:", opt,
+    while ((arg = getopt_long(argc, argv, "acdDhrRH:b:u:p:f:", opt,
             &idx)) != -1) {
         switch (arg) {
             case 'a':
@@ -1005,6 +1008,12 @@
                     PROFILE_NAME_SIZE) == NULL)
                     vah_error(ctl, 1, "error copying UUID");
                 break;
+            case 'p':
+                if (STREQ(optarg, "1"))
+                    ctl->allowDiskFormatProbing = true;
+                else
+                    ctl->allowDiskFormatProbing = false;
+                break;
             default:
                 vah_error(ctl, 1, "unsupported option");
                 break;
Index: libvirt-0.7.5/src/storage/storage_backend_fs.c
===================================================================
--- libvirt-0.7.5.orig/src/storage/storage_backend_fs.c	2010-09-01 09:42:05.000000000 -0500
+++ libvirt-0.7.5/src/storage/storage_backend_fs.c	2010-09-01 09:42:12.000000000 -0500
@@ -78,14 +78,19 @@
 
     memset(&meta, 0, sizeof(meta));
 
-    if (virStorageFileGetMetadataFromFD(conn, target->path, fd, &meta) < 0) {
+    if ((target->format = virStorageFileProbeFormatFromFD(conn, target->path, fd)) < 0) {
         close(fd);
         return -1;
     }
 
-    close(fd);
+    if (virStorageFileGetMetadataFromFD(conn, target->path, fd,
+                                        target->format,
+                                        &meta) < 0) {
+        close(fd);
+        return -1;
+    }
 
-    target->format = meta.format;
+    close(fd);
 
     if (backingStore) {
         *backingStore = meta.backingStore;
Index: libvirt-0.7.5/src/conf/domain_conf.c
===================================================================
--- libvirt-0.7.5.orig/src/conf/domain_conf.c	2010-09-01 09:42:12.000000000 -0500
+++ libvirt-0.7.5/src/conf/domain_conf.c	2010-09-01 09:42:12.000000000 -0500
@@ -41,6 +41,7 @@
 #include "c-ctype.h"
 #include "logging.h"
 #include "network.h"
+#include "storage_file.h"
 
 #define VIR_FROM_THIS VIR_FROM_DOMAIN
 
@@ -736,6 +737,7 @@
  */
 static virDomainDiskDefPtr
 virDomainDiskDefParseXML(virConnectPtr conn,
+                         virCapsPtr caps,
                          xmlNodePtr node,
                          int flags) {
     virDomainDiskDefPtr def;
@@ -952,6 +954,16 @@
     def->serial = serial;
     serial = NULL;
 
+    if (!def->driverType &&
+        caps->defaultDiskDriverType &&
+        !(def->driverType = strdup(caps->defaultDiskDriverType)))
+        goto no_memory;
+
+    if (!def->driverName &&
+        caps->defaultDiskDriverName &&
+        !(def->driverName = strdup(caps->defaultDiskDriverName)))
+        goto no_memory;
+
 cleanup:
     VIR_FREE(bus);
     VIR_FREE(type);
@@ -967,6 +979,9 @@
 
     return def;
 
+no_memory:
+    virReportOOMError(conn);
+
  error:
     virDomainDiskDefFree(def);
     def = NULL;
@@ -2619,7 +2634,7 @@
 
     if (xmlStrEqual(node->name, BAD_CAST "disk")) {
         dev->type = VIR_DOMAIN_DEVICE_DISK;
-        if (!(dev->data.disk = virDomainDiskDefParseXML(conn, node, flags)))
+        if (!(dev->data.disk = virDomainDiskDefParseXML(conn, caps, node, flags)))
             goto error;
     } else if (xmlStrEqual(node->name, BAD_CAST "filesystem")) {
         dev->type = VIR_DOMAIN_DEVICE_FS;
@@ -3028,7 +3043,7 @@
     if (n && VIR_ALLOC_N(def->disks, n) < 0)
         goto no_memory;
     for (i = 0 ; i < n ; i++) {
-        virDomainDiskDefPtr disk = virDomainDiskDefParseXML(conn,
+        virDomainDiskDefPtr disk = virDomainDiskDefParseXML(conn, caps,
                                                             nodes[i],
                                                             flags);
         if (!disk)
@@ -5379,4 +5394,103 @@
     return -1;
 }
 
+int virDomainDiskDefForeachPath(virConnectPtr conn,
+                                virDomainDiskDefPtr disk,
+                                bool allowProbing,
+                                bool ignoreOpenFailure,
+                                virDomainDiskDefPathIterator iter,
+                                void *opaque)
+{
+    virHashTablePtr paths;
+    int format;
+    int ret = -1;
+    int depth = 0;
+    char *nextpath = NULL;
+
+    if (!disk->src)
+        return 0;
+
+    if (disk->driverType) {
+        const char *formatStr = disk->driverType;
+        if (STREQ(formatStr, "aio"))
+            formatStr = "raw"; /* Xen compat */
+
+        if ((format = virStorageFileFormatTypeFromString(formatStr)) < 0) {
+            virDomainReportError(conn, VIR_ERR_INTERNAL_ERROR,
+                                 _("unknown disk format '%s' for %s"),
+                                 disk->driverType, disk->src);
+            return -1;
+        }
+    } else {
+        if (allowProbing) {
+            format = VIR_STORAGE_FILE_AUTO;
+        } else {
+            virDomainReportError(conn, VIR_ERR_INTERNAL_ERROR,
+                                 _("no disk format for %s and probing is disabled"),
+                                 disk->src);
+            return -1;
+        }
+    }
+
+    paths = virHashCreate(5);
+
+    do {
+        virStorageFileMetadata meta;
+        const char *path = nextpath ? nextpath : disk->src;
+        int fd;
+
+        if (iter(disk, path, depth, opaque) < 0)
+            goto cleanup;
+
+        if (virHashLookup(paths, path)) {
+            virDomainReportError(conn, VIR_ERR_INTERNAL_ERROR,
+                                 _("backing store for %s is self-referential"),
+                                 disk->src);
+            goto cleanup;
+        }
+
+        if ((fd = open(path, O_RDONLY)) < 0) {
+            if (ignoreOpenFailure) {
+                char ebuf[1024];
+                VIR_WARN("Ignoring open failure on %s: %s", path,
+                         virStrerror(errno, ebuf, sizeof(ebuf)));
+                break;
+            } else {
+                virReportSystemError(conn, errno,
+                                     _("unable to open disk path %s"),
+                                     path);
+                goto cleanup;
+            }
+        }
+
+        if (virStorageFileGetMetadataFromFD(conn, path, fd, format, &meta) < 0) {
+            close(fd);
+            goto cleanup;
+        }
+        close(fd);
+
+        if (virHashAddEntry(paths, path, (void*)0x1) < 0) {
+            virReportOOMError(conn);
+            goto cleanup;
+        }
+
+        depth++;
+        nextpath = meta.backingStore;
+
+        format = meta.backingStoreFormat;
+
+        if (format == VIR_STORAGE_FILE_AUTO &&
+            !allowProbing)
+            format = VIR_STORAGE_FILE_RAW; /* Stops further recursion */
+    } while (nextpath);
+
+    ret = 0;
+
+cleanup:
+    virHashFree(paths, NULL);
+    VIR_FREE(nextpath);
+
+    return ret;
+}
+
 #endif /* ! PROXY */
Index: libvirt-0.7.5/src/conf/domain_conf.h
===================================================================
--- libvirt-0.7.5.orig/src/conf/domain_conf.h	2010-09-01 09:42:05.000000000 -0500
+++ libvirt-0.7.5/src/conf/domain_conf.h	2010-09-01 09:42:12.000000000 -0500
@@ -827,6 +827,18 @@
                                      int maxnames);
 
 
+typedef int (*virDomainDiskDefPathIterator)(virDomainDiskDefPtr disk,
+                                            const char *path,
+                                            unsigned int depth,
+                                            void *opaque);
+
+int virDomainDiskDefForeachPath(virConnectPtr conn,
+                                virDomainDiskDefPtr disk,
+                                bool allowProbing,
+                                bool ignoreOpenFailure,
+                                virDomainDiskDefPathIterator iter,
+                                void *opaque);
+
 VIR_ENUM_DECL(virDomainVirt)
 VIR_ENUM_DECL(virDomainBoot)
 VIR_ENUM_DECL(virDomainFeature)
Index: libvirt-0.7.5/src/security/security_apparmor.c
===================================================================
--- libvirt-0.7.5.orig/src/security/security_apparmor.c	2010-09-01 09:42:12.000000000 -0500
+++ libvirt-0.7.5/src/security/security_apparmor.c	2010-09-01 09:42:12.000000000 -0500
@@ -148,14 +148,15 @@
  * load (add) a profile. Will create one if necessary
  */
 static int
-load_profile(virConnectPtr conn, const char *profile, virDomainObjPtr vm,
-             virDomainDiskDefPtr disk)
+load_profile(virConnectPtr conn, virSecurityDriverPtr drv, const char *profile,
+             virDomainObjPtr vm, virDomainDiskDefPtr disk)
 {
     int rc = -1, status, ret;
     bool create = true;
     char *xml = NULL;
     int pipefd[2];
     pid_t child;
+    const char *probe = virSecurityDriverGetAllowDiskFormatProbing(drv) ? "1" : "0";
 
     if (pipe(pipefd) < -1) {
         virReportSystemError(conn, errno, "%s", _("unable to create pipe"));
@@ -171,19 +172,19 @@
 
     if (create) {
         const char *const argv[] = {
-            VIRT_AA_HELPER, "-c", "-u", profile, NULL
+            VIRT_AA_HELPER, "-p", probe, "-c", "-u", profile, NULL
         };
         ret = virExec(conn, argv, NULL, NULL, &child,
                       pipefd[0], NULL, NULL, VIR_EXEC_NONE);
     } else if (disk && disk->src) {
         const char *const argv[] = {
-            VIRT_AA_HELPER, "-r", "-u", profile, "-f", disk->src, NULL
+            VIRT_AA_HELPER, "-p", probe, "-r", "-u", profile, "-f", disk->src, NULL
         };
         ret = virExec(conn, argv, NULL, NULL, &child,
                       pipefd[0], NULL, NULL, VIR_EXEC_NONE);
     } else {
         const char *const argv[] = {
-            VIRT_AA_HELPER, "-r", "-u", profile, NULL
+            VIRT_AA_HELPER, "-p", probe, "-r", "-u", profile, NULL
         };
         ret = virExec(conn, argv, NULL, NULL, &child,
                       pipefd[0], NULL, NULL, VIR_EXEC_NONE);
@@ -310,9 +311,11 @@
  * currently not used.
  */
 static int
-AppArmorSecurityDriverOpen(virConnectPtr conn, virSecurityDriverPtr drv)
+AppArmorSecurityDriverOpen(virConnectPtr conn ATTRIBUTE_UNUSED,
+                           virSecurityDriverPtr drv,
+                           bool allowDiskFormatProbing)
 {
-    virSecurityDriverSetDOI(conn, drv, SECURITY_APPARMOR_VOID_DOI);
+    virSecurityDriverSetAllowDiskFormatProbing(drv, allowDiskFormatProbing);
     return 0;
 }
 
@@ -322,7 +325,8 @@
  * called on shutdown.
 */
 static int
-AppArmorGenSecurityLabel(virConnectPtr conn, virDomainObjPtr vm)
+AppArmorGenSecurityLabel(virConnectPtr conn, virSecurityDriverPtr drv,
+                         virDomainObjPtr vm)
 {
     int rc = -1;
     char *profile_name = NULL;
@@ -340,7 +344,7 @@
 
     /* if the profile is not already loaded, then load one */
     if (profile_loaded(profile_name) < 0) {
-        if (load_profile(conn, profile_name, vm, NULL) < 0) {
+        if (load_profile(conn, drv, profile_name, vm, NULL) < 0) {
             virSecurityReportError(conn, VIR_ERR_INTERNAL_ERROR,
                                    _("cannot generate AppArmor profile "
                                    "\'%s\'"), profile_name);
@@ -479,6 +483,7 @@
 /* Called when hotplugging */
 static int
 AppArmorRestoreSecurityImageLabel(virConnectPtr conn,
+                                  virSecurityDriverPtr drv,
                                   virDomainObjPtr vm,
                                   virDomainDiskDefPtr disk ATTRIBUTE_UNUSED)
 {
@@ -492,7 +497,7 @@
 
         /* Update the profile only if it is loaded */
         if (profile_loaded(secdef->imagelabel) >= 0) {
-            if (load_profile(conn, secdef->imagelabel, vm, NULL) < 0) {
+            if (load_profile(conn, drv, secdef->imagelabel, vm, NULL) < 0) {
                 virSecurityReportError(conn, VIR_ERR_INTERNAL_ERROR,
                                        _("cannot update AppArmor profile "
                                        "\'%s\'"),
@@ -510,7 +515,7 @@
 
 /* Called when hotplugging */
 static int
-AppArmorSetSecurityImageLabel(virConnectPtr conn,
+AppArmorSetSecurityImageLabel(virConnectPtr conn, virSecurityDriverPtr drv,
                               virDomainObjPtr vm, virDomainDiskDefPtr disk)
 {
     const virSecurityLabelDefPtr secdef = &vm->def->seclabel;
@@ -533,7 +538,7 @@
 
         /* update the profile only if it is loaded */
         if (profile_loaded(secdef->imagelabel) >= 0) {
-            if (load_profile(conn, secdef->imagelabel, vm, disk) < 0) {
+            if (load_profile(conn, drv, secdef->imagelabel, vm, disk) < 0) {
                 virSecurityReportError(conn, VIR_ERR_INTERNAL_ERROR,
                                      _("cannot update AppArmor profile "
                                      "\'%s\'"),
@@ -568,6 +573,7 @@
 
 static int
 AppArmorReserveSecurityLabel(virConnectPtr conn ATTRIBUTE_UNUSED,
+                            virSecurityDriverPtr drv ATTRIBUTE_UNUSED,
                             virDomainObjPtr vm ATTRIBUTE_UNUSED)
 {
     /* NOOP. Nothing to reserve with AppArmor */
@@ -576,6 +582,7 @@
 
 static int
 AppArmorSetSecurityHostdevLabel(virConnectPtr conn ATTRIBUTE_UNUSED,
+                                virSecurityDriverPtr drv ATTRIBUTE_UNUSED,
                                 virDomainObjPtr vm ATTRIBUTE_UNUSED,
                                 virDomainHostdevDefPtr dev ATTRIBUTE_UNUSED)
 
@@ -586,6 +593,7 @@
 
 static int
 AppArmorRestoreSecurityHostdevLabel(virConnectPtr conn ATTRIBUTE_UNUSED,
+                                    virSecurityDriverPtr drv ATTRIBUTE_UNUSED,
                                     virDomainHostdevDefPtr dev ATTRIBUTE_UNUSED)
 
 {
Index: libvirt-0.7.5/src/security/security_driver.h
===================================================================
--- libvirt-0.7.5.orig/src/security/security_driver.h	2010-09-01 09:42:05.000000000 -0500
+++ libvirt-0.7.5/src/security/security_driver.h	2010-09-01 09:42:12.000000000 -0500
@@ -28,28 +28,41 @@
 
 typedef struct _virSecurityDriver virSecurityDriver;
 typedef virSecurityDriver *virSecurityDriverPtr;
+
+typedef struct _virSecurityDriverState virSecurityDriverState;
+typedef virSecurityDriverState *virSecurityDriverStatePtr;
+
 typedef virSecurityDriverStatus (*virSecurityDriverProbe) (void);
 typedef int (*virSecurityDriverOpen) (virConnectPtr conn,
-                                      virSecurityDriverPtr drv);
+                                      virSecurityDriverPtr drv,
+                                      bool allowDiskFormatProbing);
 typedef int (*virSecurityDomainRestoreImageLabel) (virConnectPtr conn,
+                                                   virSecurityDriverPtr drv,
                                                    virDomainObjPtr vm,
                                                    virDomainDiskDefPtr disk);
 typedef int (*virSecurityDomainSetImageLabel) (virConnectPtr conn,
+                                               virSecurityDriverPtr drv,
                                                virDomainObjPtr vm,
                                                virDomainDiskDefPtr disk);
 typedef int (*virSecurityDomainRestoreHostdevLabel) (virConnectPtr conn,
+                                                     virSecurityDriverPtr drv,
                                                      virDomainHostdevDefPtr dev);
 typedef int (*virSecurityDomainSetHostdevLabel) (virConnectPtr conn,
+                                                 virSecurityDriverPtr drv,
                                                  virDomainObjPtr vm,
                                                  virDomainHostdevDefPtr dev);
 typedef int (*virSecurityDomainSetSavedStateLabel) (virConnectPtr conn,
+                                                    virSecurityDriverPtr drv,
                                                     virDomainObjPtr vm,
                                                     const char *savefile);
 typedef int (*virSecurityDomainRestoreSavedStateLabel) (virConnectPtr conn,
+                                                        virSecurityDriverPtr drv,
                                                         const char *savefile);
 typedef int (*virSecurityDomainGenLabel) (virConnectPtr conn,
+                                          virSecurityDriverPtr drv,
                                           virDomainObjPtr sec);
 typedef int (*virSecurityDomainReserveLabel) (virConnectPtr conn,
+                                              virSecurityDriverPtr drv,
                                            virDomainObjPtr sec);
 typedef int (*virSecurityDomainGetLabel) (virConnectPtr conn,
                                           virDomainObjPtr vm,
@@ -85,12 +98,14 @@
      */
     struct {
         char doi[VIR_SECURITY_DOI_BUFLEN];
+        bool allowDiskFormatProbing;
     } _private;
 };
 
 /* Global methods */
 int virSecurityDriverStartup(virSecurityDriverPtr *drv,
-                             const char *name);
+                             const char *name,
+                             bool allowDiskFormatProbing);
 
 int
 virSecurityDriverVerify(virConnectPtr conn, virDomainDefPtr def);
@@ -104,7 +119,10 @@
 int virSecurityDriverSetDOI(virConnectPtr conn,
                             virSecurityDriverPtr drv,
                             const char *doi);
+void virSecurityDriverSetAllowDiskFormatProbing(virSecurityDriverPtr drv,
+                                                bool allowDiskFormatProbing);
 const char *virSecurityDriverGetDOI(virSecurityDriverPtr drv);
 const char *virSecurityDriverGetModel(virSecurityDriverPtr drv);
+bool virSecurityDriverGetAllowDiskFormatProbing(virSecurityDriverPtr drv);
 
 #endif /* __VIR_SECURITY_H__ */
Index: libvirt-0.7.5/src/qemu/libvirtd_qemu.aug
===================================================================
--- libvirt-0.7.5.orig/src/qemu/libvirtd_qemu.aug	2010-09-01 09:42:05.000000000 -0500
+++ libvirt-0.7.5/src/qemu/libvirtd_qemu.aug	2010-09-01 09:42:12.000000000 -0500
@@ -36,6 +36,7 @@
                  | str_array_entry "cgroup_device_acl"
                  | str_entry "save_image_format"
                  | str_entry "hugetlbfs_mount"
+                 | bool_entry "allow_disk_format_probing"
 
    (* Each enty in the config is one of the following three ... *)
    let entry = vnc_entry
Index: libvirt-0.7.5/src/qemu/qemu.conf
===================================================================
--- libvirt-0.7.5.orig/src/qemu/qemu.conf	2010-09-01 09:42:11.000000000 -0500
+++ libvirt-0.7.5/src/qemu/qemu.conf	2010-09-01 09:42:12.000000000 -0500
@@ -159,3 +159,13 @@
 # This currently requires ebtables to be installed.
 #
 # mac_filter = 1
+
+# If allow_disk_format_probing is enabled, libvirt will probe disk
+# images to attempt to identify their format, when not otherwise
+# specified in the XML. This is disabled by default.
+#
+# WARNING: Enabling probing is a security hole in almost all
+# deployments. It is strongly recommended that users update their
+# guest XML <disk> elements to include  <driver type='XXXX'/>
+# elements instead of enabling this option.
+# allow_disk_format_probing = 1
Index: libvirt-0.7.5/src/qemu/qemu_conf.c
===================================================================
--- libvirt-0.7.5.orig/src/qemu/qemu_conf.c	2010-09-01 09:42:05.000000000 -0500
+++ libvirt-0.7.5/src/qemu/qemu_conf.c	2010-09-01 09:42:12.000000000 -0500
@@ -340,6 +340,10 @@
         }
     }
 
+    p = virConfGetValue (conf, "allow_disk_format_probing");
+    CHECK_TYPE ("allow_disk_format_probing", VIR_CONF_LONG);
+    if (p) driver->allowDiskFormatProbing = p->l;
+
     virConfFree (conf);
     return 0;
 }
Index: libvirt-0.7.5/src/qemu/qemu_conf.h
===================================================================
--- libvirt-0.7.5.orig/src/qemu/qemu_conf.h	2010-09-01 09:42:05.000000000 -0500
+++ libvirt-0.7.5/src/qemu/qemu_conf.h	2010-09-01 09:42:12.000000000 -0500
@@ -120,6 +120,7 @@
 
     unsigned int macFilter : 1;
     ebtablesContext *ebtables;
+    unsigned int allowDiskFormatProbing : 1;
 
     virCapsPtr caps;
 
Index: libvirt-0.7.5/src/qemu/test_libvirtd_qemu.aug
===================================================================
--- libvirt-0.7.5.orig/src/qemu/test_libvirtd_qemu.aug	2010-09-01 09:42:05.000000000 -0500
+++ libvirt-0.7.5/src/qemu/test_libvirtd_qemu.aug	2010-09-01 09:42:12.000000000 -0500
@@ -93,6 +93,8 @@
 save_image_format = \"gzip\"
 
 hugetlbfs_mount = \"/dev/hugepages\"
+
+allow_disk_format_probing = 1
 "
 
    test Libvirtd_qemu.lns get conf =
@@ -195,4 +197,6 @@
 { "#empty" }
 { "save_image_format" = "gzip" }
 { "#empty" }
-{ "hugetlbfs_mount" = "/dev/hugepages" }
\ No newline at end of file
+{ "hugetlbfs_mount" = "/dev/hugepages" }
+{ "#empty" }
+{ "allow_disk_format_probing" = "1" }
Index: libvirt-0.7.5/src/security/security_driver.c
===================================================================
--- libvirt-0.7.5.orig/src/security/security_driver.c	2010-09-01 09:42:05.000000000 -0500
+++ libvirt-0.7.5/src/security/security_driver.c	2010-09-01 09:42:12.000000000 -0500
@@ -56,7 +56,8 @@
 
 int
 virSecurityDriverStartup(virSecurityDriverPtr *drv,
-                         const char *name)
+                         const char *name,
+                         bool allowDiskFormatProbing)
 {
     unsigned int i;
 
@@ -72,7 +73,7 @@
         switch (tmp->probe()) {
         case SECURITY_DRIVER_ENABLE:
             virSecurityDriverInit(tmp);
-            if (tmp->open(NULL, tmp) == -1) {
+            if (tmp->open(NULL, tmp, allowDiskFormatProbing) == -1) {
                 return -1;
             } else {
                 *drv = tmp;
@@ -144,3 +145,15 @@
 {
     return drv->name;
 }
+
+void virSecurityDriverSetAllowDiskFormatProbing(virSecurityDriverPtr drv,
+                                                bool allowDiskFormatProbing)
+{
+    drv->_private.allowDiskFormatProbing = allowDiskFormatProbing;
+}
+
+bool
+virSecurityDriverGetAllowDiskFormatProbing(virSecurityDriverPtr drv)
+{
+    return drv->_private.allowDiskFormatProbing;
+}
Index: libvirt-0.7.5/tests/seclabeltest.c
===================================================================
--- libvirt-0.7.5.orig/tests/seclabeltest.c	2010-09-01 09:42:05.000000000 -0500
+++ libvirt-0.7.5/tests/seclabeltest.c	2010-09-01 09:42:12.000000000 -0500
@@ -15,7 +15,7 @@
     const char *doi, *model;
     virSecurityDriverPtr security_drv;
 
-    ret = virSecurityDriverStartup (&security_drv, "selinux");
+    ret = virSecurityDriverStartup (&security_drv, "selinux", false);
     if (ret == -1)
     {
         fprintf (stderr, "Failed to start security driver");
Index: libvirt-0.7.5/src/conf/capabilities.h
===================================================================
--- libvirt-0.7.5.orig/src/conf/capabilities.h	2010-09-01 09:42:05.000000000 -0500
+++ libvirt-0.7.5/src/conf/capabilities.h	2010-09-01 09:42:12.000000000 -0500
@@ -120,6 +120,8 @@
     virCapsGuestPtr *guests;
     unsigned char macPrefix[VIR_MAC_PREFIX_BUFLEN];
     unsigned int emulatorRequired : 1;
+    const char *defaultDiskDriverName;
+    const char *defaultDiskDriverType;
     void *(*privateDataAllocFunc)(void);
     void (*privateDataFreeFunc)(void *);
     int (*privateDataXMLFormat)(virBufferPtr, void *);
Index: libvirt-0.7.5/src/storage/storage_backend.c
===================================================================
--- libvirt-0.7.5.orig/src/storage/storage_backend.c	2010-09-01 09:42:05.000000000 -0500
+++ libvirt-0.7.5/src/storage/storage_backend.c	2010-09-01 09:42:12.000000000 -0500
@@ -453,15 +453,79 @@
     return ret;
 }
 
+enum {
+    QEMU_IMG_BACKING_FORMAT_NONE = 0,
+    QEMU_IMG_BACKING_FORMAT_FLAG,
+    QEMU_IMG_BACKING_FORMAT_OPTIONS,
+};
+
+static int virStorageBackendQEMUImgBackingFormat(virConnectPtr conn,
+                                                 const char *qemuimg)
+{
+    const char *const qemuarg[] = { qemuimg, "-h", NULL };
+    const char *const qemuenv[] = { "LC_ALL=C", NULL };
+    pid_t child = 0;
+    int status;
+    int newstdout = -1;
+    char *help = NULL;
+    enum { MAX_HELP_OUTPUT_SIZE = 1024*8 };
+    int len;
+    char *start;
+    char *end;
+    char *tmp;
+    int ret = -1;
+
+    if (virExec(conn, qemuarg, qemuenv, NULL,
+                &child, -1, &newstdout, NULL, VIR_EXEC_CLEAR_CAPS) < 0)
+        goto cleanup;
+
+    if ((len = virFileReadLimFD(newstdout, MAX_HELP_OUTPUT_SIZE, &help)) < 0) {
+        virReportSystemError(conn, errno,
+                             _("Unable to read '%s -h' output"),
+                             qemuimg);
+        goto cleanup;
+    }
+
+    start = strstr(help, " create ");
+    end = strstr(start, "\n");
+    if ((tmp = strstr(start, "-F fmt")) && tmp < end)
+        ret = QEMU_IMG_BACKING_FORMAT_FLAG;
+    else if ((tmp = strstr(start, "[-o options]")) && tmp < end)
+        ret = QEMU_IMG_BACKING_FORMAT_OPTIONS;
+    else
+        ret = QEMU_IMG_BACKING_FORMAT_NONE;
+
+cleanup:
+    VIR_FREE(help);
+    close(newstdout);
+rewait:
+    if (child) {
+        if (waitpid(child, &status, 0) != child) {
+            if (errno == EINTR)
+                goto rewait;
+
+            VIR_ERROR(_("Unexpected exit status from qemu %d pid %lu"),
+                      WEXITSTATUS(status), (unsigned long)child);
+        }
+        if (WEXITSTATUS(status) != 0) {
+            VIR_WARN("Unexpected exit status '%d', qemu probably failed",
+                     WEXITSTATUS(status));
+        }
+    }
+
+    return ret;
+}
+
+
 static int
 virStorageBackendCreateQemuImg(virConnectPtr conn,
                                virStorageVolDefPtr vol,
                                virStorageVolDefPtr inputvol,
                                unsigned int flags ATTRIBUTE_UNUSED)
 {
+    int ret = 0;
     char size[100];
     char *create_tool;
-    short use_kvmimg;
 
     const char *type = virStorageFileFormatTypeToString(vol->target.format);
     const char *backingType = vol->backingStore.path ?
@@ -472,41 +536,10 @@
     const char *inputPath = inputvol ? inputvol->target.path : NULL;
     /* Treat input block devices as 'raw' format */
     const char *inputType = inputPath ?
-                            virStorageFileFormatTypeToString(inputvol->type == VIR_STORAGE_VOL_BLOCK ? VIR_STORAGE_FILE_RAW : inputvol->target.format) :
-                            NULL;
-
-    const char **imgargv;
-    /* The extra NULL field is for indicating encryption (-e). */
-    const char *imgargvnormal[] = {
-        NULL, "create",
-        "-f", type,
-        vol->target.path,
-        size,
-        NULL,
-        NULL
-    };
-    /* Extra NULL fields are for including "backingType" when using
-     * kvm-img (-F backingType), and for indicating encryption (-e).
-     */
-    const char *imgargvbacking[] = {
-        NULL, "create",
-        "-f", type,
-        "-b", vol->backingStore.path,
-        vol->target.path,
-        size,
-        NULL,
-        NULL,
-        NULL,
-        NULL
-    };
-    const char *convargv[] = {
-        NULL, "convert",
-        "-f", inputType,
-        "-O", type,
-        inputPath,
-        vol->target.path,
-        NULL,
-    };
+        virStorageFileFormatTypeToString(inputvol->type == VIR_STORAGE_VOL_BLOCK ?
+                                         VIR_STORAGE_FILE_RAW :
+                                         inputvol->target.format) :
+        NULL;
 
     if (type == NULL) {
         virStorageReportError(conn, VIR_ERR_INTERNAL_ERROR,
@@ -580,50 +613,114 @@
         }
     }
 
-    if ((create_tool = virFindFileInPath("kvm-img")) != NULL)
-        use_kvmimg = 1;
-    else if ((create_tool = virFindFileInPath("qemu-img")) != NULL)
-        use_kvmimg = 0;
-    else {
+    /* Size in KB */
+    snprintf(size, sizeof(size), "%lluK", vol->capacity/1024);
+
+    /* KVM is usually ahead of qemu on features, so try that first */
+    create_tool = virFindFileInPath("kvm-img");
+    if (!create_tool)
+        create_tool = virFindFileInPath("qemu-img");
+
+    if (!create_tool) {
         virStorageReportError(conn, VIR_ERR_INTERNAL_ERROR,
                               "%s", _("unable to find kvm-img or qemu-img"));
         return -1;
     }
 
     if (inputvol) {
-        convargv[0] = create_tool;
-        imgargv = convargv;
+        const char *imgargv[] = {
+            create_tool,
+            "convert",
+            "-f", inputType,
+            "-O", type,
+            inputPath,
+            vol->target.path,
+            NULL,
+        };
+        if (virRun(conn, imgargv, NULL) < 0) {
+            ret = -1;
+            goto cleanup;
+        }
     } else if (vol->backingStore.path) {
-        imgargvbacking[0] = create_tool;
-        if (use_kvmimg) {
-            imgargvbacking[6] = "-F";
-            imgargvbacking[7] = backingType;
-            imgargvbacking[8] = vol->target.path;
-            imgargvbacking[9] = size;
+        const char *imgargv[] = {
+            create_tool,
+            "create",
+            "-f", type,
+            "-b", vol->backingStore.path,
+            NULL,
+            NULL,
+            NULL,
+            NULL,
+            NULL,
+            NULL
+        };
+        int imgformat = virStorageBackendQEMUImgBackingFormat(conn, create_tool);
+        char *optflag = NULL;
+        if (imgformat < 0)
+            goto cleanup;
+
+        switch (imgformat) {
+        case QEMU_IMG_BACKING_FORMAT_FLAG:
+            imgargv[6] = "-F";
+            imgargv[7] = backingType;
+            imgargv[8] = vol->target.path;
+            imgargv[9] = size;
             if (vol->target.encryption != NULL)
-                imgargvbacking[10] = "-e";
-        } else if (vol->target.encryption != NULL)
-            imgargvbacking[8] = "-e";
-        imgargv = imgargvbacking;
+                imgargv[10] = "-e";
+            break;
+
+        case QEMU_IMG_BACKING_FORMAT_OPTIONS:
+            if (virAsprintf(&optflag, "backing_fmt=%s", backingType) < 0) {
+                virReportOOMError(conn);
+                goto cleanup;
+            }
+            imgargv[6] = "-o";
+            imgargv[7] = optflag;
+            imgargv[8] = vol->target.path;
+            imgargv[9] = size;
+            if (vol->target.encryption != NULL)
+                imgargv[10] = "-e";
+            break;
+
+        default:
+            VIR_INFO("Unable to set backing store format for %s with %s",
+                     vol->target.path, create_tool);
+            imgargv[6] = vol->target.path;
+            imgargv[7] = size;
+            if (vol->target.encryption != NULL)
+                imgargv[8] = "-e";
+        }
+
+        if (virRun(conn, imgargv, NULL) < 0) {
+            ret = -1;
+            VIR_FREE(optflag);
+            goto cleanup;
+        }
+        VIR_FREE(optflag);
     } else {
-        imgargvnormal[0] = create_tool;
-        imgargv = imgargvnormal;
+        /* The extra NULL field is for indicating encryption (-e). */
+        const char *imgargv[] = {
+            create_tool,
+            "create",
+            "-f", type,
+            vol->target.path,
+            size,
+            NULL,
+            NULL
+        };
         if (vol->target.encryption != NULL)
             imgargv[6] = "-e";
-    }
-
-
-    /* Size in KB */
-    snprintf(size, sizeof(size), "%lluK", vol->capacity/1024);
 
-    if (virRun(conn, imgargv, NULL) < 0) {
-        VIR_FREE(imgargv[0]);
-        return -1;
+        if (virRun(conn, imgargv, NULL) < 0) {
+            ret = -1;
+            goto cleanup;
+        }
     }
 
-    VIR_FREE(imgargv[0]);
+    cleanup:
+    VIR_FREE(create_tool);
 
-    return 0;
+    return ret;
 }
 
 /*
Index: libvirt-0.7.5/tests/secaatest.c
===================================================================
--- libvirt-0.7.5.orig/tests/secaatest.c	2010-09-01 09:42:05.000000000 -0500
+++ libvirt-0.7.5/tests/secaatest.c	2010-09-01 09:42:12.000000000 -0500
@@ -15,7 +15,7 @@
     const char *doi, *model;
     virSecurityDriverPtr security_drv;
 
-    ret = virSecurityDriverStartup (&security_drv, "apparmor");
+    ret = virSecurityDriverStartup (&security_drv, "apparmor", false);
     if (ret == -1)
     {
         fprintf (stderr, "Failed to start security driver");
Index: libvirt-0.7.5/tests/virt-aa-helper-test
===================================================================
--- libvirt-0.7.5.orig/tests/virt-aa-helper-test	2010-09-01 09:42:12.000000000 -0500
+++ libvirt-0.7.5/tests/virt-aa-helper-test	2010-09-01 09:42:12.000000000 -0500
@@ -76,6 +76,7 @@
   <devices>
     <emulator>/usr/bin/kvm</emulator>
     <disk type='file' device='disk'>
+      <driver name='qemu' type='raw'/>
       <source file='###DISK###'/>
       <target dev='hda' bus='ide'/>
     </disk>
@@ -143,6 +144,7 @@
 testme "1" "invalid arg" "-z"
 testme "1" "invalid case" "-A"
 testme "1" "not enough args" "-c"
+testme "1" "not enough args" "-p"
 
 cat "$template_xml" | sed "s,###UUID###,$uuid,g" | sed "s,###DISK###,$disk1,g" > "$test_xml"
 testme "1" "no -u with -c" "-c" "$test_xml"
@@ -159,17 +161,24 @@
 cat "$template_xml" | sed "s,###UUID###,$uuid,g" | sed "s,###DISK###,$bad_disk,g" > "$test_xml"
 testme "1" "bad disk" "-c -u $valid_uuid" "$test_xml"
 
-cat "$template_xml" | sed "s,###UUID###,$uuid,g" | sed "s,###DISK###,$bad_disk,g" | sed "s,</devices>,<disk type='file' device='disk'><source file='$disk2'/><target dev='hda' bus='ide'/></disk></devices>,g" > "$test_xml"
+cat "$template_xml" | sed "s,###UUID###,$uuid,g" | sed "s,###DISK###,$bad_disk,g" | sed "s,</devices>,<disk type='file' device='disk'><driver name='qemu' type='raw'/><source file='$disk2'/><target dev='hda' bus='ide'/></disk></devices>,g" > "$test_xml"
 testme "1" "bad disk2" "-c -u $valid_uuid" "$test_xml"
 
 cat "$template_xml" | sed "s,###UUID###,$uuid,g" | sed "s,###DISK###,$disk1,g" | sed "s,</devices>,<devices>,g" > "$test_xml"
 testme "1" "malformed xml" "-c -u $valid_uuid" "$test_xml"
 
-cat "$template_xml" | sed "s,###UUID###,$uuid,g" | sed "s,###DISK###,/boot/initrd,g" > "$test_xml"
-testme "1" "disk in /boot" "-r -u $valid_uuid" "$test_xml"
-
-cat "$template_xml" | sed "s,###UUID###,$uuid,g" | sed "s,###DISK###,/boot/initrd,g" > "$test_xml"
-testme "1" "-r with invalid -f" "-r -u $valid_uuid -f $bad_disk" "$test_xml"
+initrd=`ls -1 /boot/initrd* | head -1`
+if [ -z "$initrd" ]; then
+    echo "Skipping /boot/initrd* tests. Could not find /boot/initrd*"
+else
+    cat "$template_xml" | sed "s,###UUID###,$uuid,g" | sed "s,###DISK###,$initrd,g" > "$test_xml"
+    testme "1" "disk in /boot without probing" "-p 0 -r -u $valid_uuid" "$test_xml"
+    testme "1" "disk in /boot with probing" "-p 1 -r -u $valid_uuid" "$test_xml"
+
+    cat "$template_xml" | sed "s,###UUID###,$uuid,g" | sed "s,###DISK###,/boot/initrd,g" > "$test_xml"
+    testme "1" "-r with invalid -f with probing" "-p 1 -r -u $valid_uuid -f $bad_disk" "$test_xml"
+    testme "1" "-r with invalid -f without probing" "-p 0 -r -u $valid_uuid -f $bad_disk" "$test_xml"
+fi
 
 cat "$template_xml" | sed "s,###UUID###,$uuid,g" | sed "s,###DISK###,$disk1</disk>,g" > "$test_xml"
 testme "1" "-c with malformed xml" "-c -u $valid_uuid" "$test_xml"
@@ -194,7 +203,7 @@
 cat "$template_xml" | sed "s,###UUID###,$uuid,g" | sed "s,###DISK###,$disk1,g" | sed "s,arch='x86_64',arch='ppc',g" > "$test_xml"
 testme "0" "create (ppc)" "-c -u $valid_uuid" "$test_xml"
 
-cat "$template_xml" | sed "s,###UUID###,$uuid,g" | sed "s,###DISK###,$disk1,g" | sed "s,</disk>,</disk><disk type='file' device='disk'><source file='$disk2'/><target dev='hdb' bus='ide'/></disk>,g" > "$test_xml"
+cat "$template_xml" | sed "s,###UUID###,$uuid,g" | sed "s,###DISK###,$disk1,g" | sed "s,</disk>,</disk><disk type='file' device='disk'><driver name='qemu' type='raw'/><source file='$disk2'/><target dev='hdb' bus='ide'/></disk>,g" > "$test_xml"
 testme "0" "create multiple disks" "-c -u $valid_uuid" "$test_xml"
 
 cat "$template_xml" | sed "s,###UUID###,$uuid,g" | sed "s,###DISK###',${disk1}'/><readonly,g" > "$test_xml"
