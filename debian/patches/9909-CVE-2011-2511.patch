Origin: 774b21c163845170c9ffa873f5720d318812eaf6
Description: remote: protect against integer overflow
 Integer overflow and remote code are never a nice mix.
 .
 This has existed since commit 56cd414.
 .
 * src/libvirt.c (virDomainGetVcpus): Reject overflow up front.
 * src/remote/remote_driver.c (remoteDomainGetVcpus): Avoid overflow
   on sending rpc.
 * daemon/remote.c (remoteDispatchDomainGetVcpus): Avoid overflow on
   receiving rpc.
Bug-Debian: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=633630

Index: libvirt-0.7.5/daemon/remote.c
===================================================================
--- libvirt-0.7.5.orig/daemon/remote.c	2011-07-22 15:11:05.000000000 -0500
+++ libvirt-0.7.5/daemon/remote.c	2011-07-22 15:12:29.000000000 -0500
@@ -56,6 +56,7 @@
 #include "memory.h"
 #include "util.h"
 #include "stream.h"
+#include "intprops.h"
 
 #define VIR_FROM_THIS VIR_FROM_REMOTE
 #define REMOTE_DEBUG(fmt, ...) DEBUG(fmt, __VA_ARGS__)
@@ -1328,7 +1329,8 @@
         return -1;
     }
 
-    if (args->maxinfo * args->maplen > REMOTE_CPUMAPS_MAX) {
+    if (INT_MULTIPLY_OVERFLOW(args->maxinfo, args->maplen) ||
+        args->maxinfo * args->maplen > REMOTE_CPUMAPS_MAX) {
         virDomainFree(dom);
         remoteDispatchFormatError (rerr, "%s", _("maxinfo * maplen > REMOTE_CPUMAPS_MAX"));
         return -1;
Index: libvirt-0.7.5/gnulib/lib/intprops.h
===================================================================
--- libvirt-0.7.5.orig/gnulib/lib/intprops.h	2011-07-22 15:11:05.000000000 -0500
+++ libvirt-0.7.5/gnulib/lib/intprops.h	2011-07-22 15:11:15.000000000 -0500
@@ -80,4 +80,65 @@
    including the terminating null.  */
 # define INT_BUFSIZE_BOUND(t) (INT_STRLEN_BOUND (t) + 1)
 
+#define INT_MULTIPLY_OVERFLOW(a, b) \
+  _GL_BINARY_OP_OVERFLOW (a, b, _GL_MULTIPLY_OVERFLOW)
+
+/* Return 1 if the expression A <op> B would overflow,
+   where OP_RESULT_OVERFLOW (A, B, MIN, MAX) does the actual test,
+   assuming MIN and MAX are the minimum and maximum for the result type.
+   Arguments should be free of side effects.  */
+#define _GL_BINARY_OP_OVERFLOW(a, b, op_result_overflow)        \
+  op_result_overflow (a, b,                                     \
+                      _GL_INT_MINIMUM (0 * (b) + (a)),          \
+                      _GL_INT_MAXIMUM (0 * (b) + (a)))
+
+/* The maximum and minimum values for the type of the expression E,
+   after integer promotion.  E should not have side effects.  */
+#define _GL_INT_MINIMUM(e)                                              \
+  (_GL_INT_SIGNED (e)                                                   \
+   ? - _GL_INT_TWOS_COMPLEMENT (e) - _GL_SIGNED_INT_MAXIMUM (e)         \
+   : _GL_INT_CONVERT (e, 0))
+#define _GL_INT_MAXIMUM(e)                                              \
+  (_GL_INT_SIGNED (e)                                                   \
+   ? _GL_SIGNED_INT_MAXIMUM (e)                                         \
+   : _GL_INT_NEGATE_CONVERT (e, 1))
+#define _GL_SIGNED_INT_MAXIMUM(e)                                       \
+  (((_GL_INT_CONVERT (e, 1) << (sizeof ((e) + 0) * CHAR_BIT - 2)) - 1) * 2 + 1)
+
+/* Return 1 if the integer expression E, after integer promotion, has
+   a signed type.  */
+#define _GL_INT_SIGNED(e) (_GL_INT_NEGATE_CONVERT (e, 1) < 0)
+
+/* Act like _GL_INT_CONVERT (E, -V) but work around a bug in IRIX 6.5 cc; see
+   <http://lists.gnu.org/archive/html/bug-gnulib/2011-05/msg00406.html>.  */
+#define _GL_INT_NEGATE_CONVERT(e, v) (0 * (e) - (v))
+
+/* Return an integer value, converted to the same type as the integer
+   expression E after integer type promotion.  V is the unconverted value.  */
+#define _GL_INT_CONVERT(e, v) (0 * (e) + (v))
+
+/* True if the signed integer expression E uses two's complement.  */
+#define _GL_INT_TWOS_COMPLEMENT(e) (~ _GL_INT_CONVERT (e, 0) == -1)
+
+#define _GL_MULTIPLY_OVERFLOW(a, b, min, max)                           \
+  (((min) == 0 && (((a) < 0 && 0 < (b)) || ((b) < 0 && 0 < (a))))       \
+   || INT_MULTIPLY_RANGE_OVERFLOW (a, b, min, max))
+
+/* Return 1 if A * B would overflow in [MIN,MAX] arithmetic.
+   See above for restrictions.  Avoid && and || as they tickle
+   bugs in Sun C 5.11 2010/08/13 and other compilers; see
+   <http://lists.gnu.org/archive/html/bug-gnulib/2011-05/msg00401.html>.  */
+#define INT_MULTIPLY_RANGE_OVERFLOW(a, b, min, max)     \
+  ((b) < 0                                              \
+   ? ((a) < 0                                           \
+      ? (a) < (max) / (b)                               \
+      : (b) == -1                                       \
+      ? 0                                               \
+      : (min) / (b) < (a))                              \
+   : (b) == 0                                           \
+   ? 0                                                  \
+   : ((a) < 0                                           \
+      ? (a) < (min) / (b)                               \
+      : (max) / (b) < (a)))
+
 #endif /* GL_INTPROPS_H */
Index: libvirt-0.7.5/src/libvirt.c
===================================================================
--- libvirt-0.7.5.orig/src/libvirt.c	2011-07-22 15:11:05.000000000 -0500
+++ libvirt-0.7.5/src/libvirt.c	2011-07-22 15:11:15.000000000 -0500
@@ -41,6 +41,7 @@
 #include "uuid.h"
 #include "util.h"
 #include "memory.h"
+#include "intprops.h"
 
 #ifndef WITH_DRIVER_MODULES
 #ifdef WITH_TEST
@@ -4914,8 +4915,8 @@
 
     /* Ensure that domainGetVcpus (aka remoteDomainGetVcpus) does not
        try to memcpy anything into a NULL pointer.  */
-    if ((cpumaps == NULL && maplen != 0)
-        || (cpumaps && maplen <= 0)) {
+    if (!cpumaps ? maplen != 0
+        : (maplen <= 0 || INT_MULTIPLY_OVERFLOW(maxinfo, maplen))) {
         virLibDomainError(domain, VIR_ERR_INVALID_ARG, __FUNCTION__);
         goto error;
     }
Index: libvirt-0.7.5/src/remote/remote_driver.c
===================================================================
--- libvirt-0.7.5.orig/src/remote/remote_driver.c	2011-07-22 15:11:05.000000000 -0500
+++ libvirt-0.7.5/src/remote/remote_driver.c	2011-07-22 15:14:13.000000000 -0500
@@ -87,6 +87,7 @@
 #include "memory.h"
 #include "util.h"
 #include "event.h"
+#include "intprops.h"
 
 #define VIR_FROM_THIS VIR_FROM_REMOTE
 
@@ -2455,7 +2456,8 @@
                 maxinfo, REMOTE_VCPUINFO_MAX);
         goto done;
     }
-    if (maxinfo * maplen > REMOTE_CPUMAPS_MAX) {
+    if (INT_MULTIPLY_OVERFLOW(maxinfo, maplen) ||
+        maxinfo * maplen > REMOTE_CPUMAPS_MAX) {
         errorf (domain->conn, VIR_ERR_RPC,
                 _("vCPU map buffer length exceeds maximum: %d > %d"),
                 maxinfo * maplen, REMOTE_CPUMAPS_MAX);
