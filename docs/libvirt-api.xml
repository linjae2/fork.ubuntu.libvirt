<?xml version="1.0" encoding="ISO-8859-1"?>
<api name='libvirt'>
  <files>
    <file name='libvirt'>
     <summary>core interfaces for the libvirt library</summary>
     <description>Provides the interfaces of the libvirt library to handle Xen domains from a process running in domain 0 </description>
     <author>Daniel Veillard &lt;veillard@redhat.com&gt; </author>
     <exports symbol='VIR_NODEINFO_MAXCPUS' type='macro'/>
     <exports symbol='LIBVIR_VERSION_NUMBER' type='macro'/>
     <exports symbol='VIR_USE_CPU' type='macro'/>
     <exports symbol='VIR_CPU_MAPLEN' type='macro'/>
     <exports symbol='VIR_CPU_USABLE' type='macro'/>
     <exports symbol='VIR_COPY_CPUMAP' type='macro'/>
     <exports symbol='VIR_GET_CPUMAP' type='macro'/>
     <exports symbol='VIR_UNUSE_CPU' type='macro'/>
     <exports symbol='VIR_DOMAIN_SHUTOFF' type='enum'/>
     <exports symbol='VIR_DOMAIN_DESTROY' type='enum'/>
     <exports symbol='VIR_DEVICE_DEFAULT' type='enum'/>
     <exports symbol='VIR_DOMAIN_RENAME_RESTART' type='enum'/>
     <exports symbol='VIR_DOMAIN_PRESERVE' type='enum'/>
     <exports symbol='VIR_VCPU_BLOCKED' type='enum'/>
     <exports symbol='VIR_DOMAIN_SHUTDOWN' type='enum'/>
     <exports symbol='VIR_VCPU_OFFLINE' type='enum'/>
     <exports symbol='VIR_DEVICE_RO' type='enum'/>
     <exports symbol='VIR_DEVICE_RW_FORCE' type='enum'/>
     <exports symbol='VIR_VCPU_RUNNING' type='enum'/>
     <exports symbol='VIR_DOMAIN_CRASHED' type='enum'/>
     <exports symbol='VIR_DOMAIN_NONE' type='enum'/>
     <exports symbol='VIR_DEVICE_RW' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCKED' type='enum'/>
     <exports symbol='VIR_DOMAIN_PAUSED' type='enum'/>
     <exports symbol='VIR_DOMAIN_RESTART' type='enum'/>
     <exports symbol='VIR_DOMAIN_RUNNING' type='enum'/>
     <exports symbol='VIR_DOMAIN_NOSTATE' type='enum'/>
     <exports symbol='virNodeInfoPtr' type='typedef'/>
     <exports symbol='virDomainInfoPtr' type='typedef'/>
     <exports symbol='virDomainKernelPtr' type='typedef'/>
     <exports symbol='virConnectPtr' type='typedef'/>
     <exports symbol='virDomainKernel' type='typedef'/>
     <exports symbol='virNodeInfo' type='typedef'/>
     <exports symbol='virDomainState' type='typedef'/>
     <exports symbol='virDeviceMode' type='typedef'/>
     <exports symbol='virDomain' type='typedef'/>
     <exports symbol='virDomainPtr' type='typedef'/>
     <exports symbol='virVcpuInfo' type='typedef'/>
     <exports symbol='virVcpuInfoPtr' type='typedef'/>
     <exports symbol='virDomainRestart' type='typedef'/>
     <exports symbol='virConnect' type='typedef'/>
     <exports symbol='virDomainCreateFlags' type='typedef'/>
     <exports symbol='virDomainInfo' type='typedef'/>
     <exports symbol='virVcpuState' type='typedef'/>
     <exports symbol='_virDomainInfo' type='struct'/>
     <exports symbol='_virDomainKernel' type='struct'/>
     <exports symbol='_virNodeInfo' type='struct'/>
     <exports symbol='_virVcpuInfo' type='struct'/>
     <exports symbol='virDomainGetInfo' type='function'/>
     <exports symbol='virDomainUndefine' type='function'/>
     <exports symbol='virDomainDefineXML' type='function'/>
     <exports symbol='virDomainShutdown' type='function'/>
     <exports symbol='virGetVersion' type='function'/>
     <exports symbol='virConnectListDefinedDomains' type='function'/>
     <exports symbol='virDomainLookupByName' type='function'/>
     <exports symbol='virDomainPinVcpu' type='function'/>
     <exports symbol='virDomainRestore' type='function'/>
     <exports symbol='virConnectGetType' type='function'/>
     <exports symbol='virDomainSave' type='function'/>
     <exports symbol='virDomainCreate' type='function'/>
     <exports symbol='virConnectListDomains' type='function'/>
     <exports symbol='virDomainLookupByUUID' type='function'/>
     <exports symbol='virDomainLookupByUUIDString' type='function'/>
     <exports symbol='virDomainLookupByID' type='function'/>
     <exports symbol='virDomainGetOSType' type='function'/>
     <exports symbol='virNodeGetInfo' type='function'/>
     <exports symbol='virDomainGetUUID' type='function'/>
     <exports symbol='virConnectNumOfDomains' type='function'/>
     <exports symbol='virDomainGetUUIDString' type='function'/>
     <exports symbol='virDomainGetVcpus' type='function'/>
     <exports symbol='virConnectGetVersion' type='function'/>
     <exports symbol='virDomainSetMaxMemory' type='function'/>
     <exports symbol='virDomainFree' type='function'/>
     <exports symbol='virConnectOpen' type='function'/>
     <exports symbol='virDomainSuspend' type='function'/>
     <exports symbol='virConnectNumOfDefinedDomains' type='function'/>
     <exports symbol='virConnectClose' type='function'/>
     <exports symbol='virDomainReboot' type='function'/>
     <exports symbol='virInitialize' type='function'/>
     <exports symbol='virDomainSetVcpus' type='function'/>
     <exports symbol='virDomainGetID' type='function'/>
     <exports symbol='virDomainResume' type='function'/>
     <exports symbol='virDomainCreateLinux' type='function'/>
     <exports symbol='virDomainSetMemory' type='function'/>
     <exports symbol='virDomainDestroy' type='function'/>
     <exports symbol='virDomainGetMaxMemory' type='function'/>
     <exports symbol='virDomainGetXMLDesc' type='function'/>
     <exports symbol='virDomainGetName' type='function'/>
     <exports symbol='virConnectOpenReadOnly' type='function'/>
    </file>
    <file name='virterror'>
     <summary>error handling interfaces for the libvirt library</summary>
     <description>Provides the interfaces of the libvirt library to handle errors raised while using the library. </description>
     <author>Daniel Veillard &lt;veillard@redhat.com&gt; </author>
     <exports symbol='VIR_ERR_CALL_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_WARNING' type='enum'/>
     <exports symbol='VIR_ERR_NO_XEN' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_ARG' type='enum'/>
     <exports symbol='VIR_ERR_ERROR' type='enum'/>
     <exports symbol='VIR_ERR_NO_DEVICE' type='enum'/>
     <exports symbol='VIR_ERR_NO_MEMORY' type='enum'/>
     <exports symbol='VIR_FROM_SEXPR' type='enum'/>
     <exports symbol='VIR_FROM_RPC' type='enum'/>
     <exports symbol='VIR_ERR_XML_ERROR' type='enum'/>
     <exports symbol='VIR_FROM_NONE' type='enum'/>
     <exports symbol='VIR_ERR_DOM_EXIST' type='enum'/>
     <exports symbol='VIR_ERR_NO_XENSTORE' type='enum'/>
     <exports symbol='VIR_FROM_DOM' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_DOMAIN' type='enum'/>
     <exports symbol='VIR_FROM_XML' type='enum'/>
     <exports symbol='VIR_FROM_CONF' type='enum'/>
     <exports symbol='VIR_ERR_PARSE_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_NO_KERNEL' type='enum'/>
     <exports symbol='VIR_ERR_POST_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_OS_TYPE' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_CONN' type='enum'/>
     <exports symbol='VIR_ERR_NONE' type='enum'/>
     <exports symbol='VIR_ERR_OK' type='enum'/>
     <exports symbol='VIR_ERR_NO_NAME' type='enum'/>
     <exports symbol='VIR_ERR_NO_ROOT' type='enum'/>
     <exports symbol='VIR_ERR_OPERATION_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_GET_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_DRIVER_FULL' type='enum'/>
     <exports symbol='VIR_ERR_HTTP_ERROR' type='enum'/>
     <exports symbol='VIR_ERR_NO_SOURCE' type='enum'/>
     <exports symbol='VIR_ERR_NO_TARGET' type='enum'/>
     <exports symbol='VIR_ERR_OPERATION_DENIED' type='enum'/>
     <exports symbol='VIR_ERR_WRITE_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_INTERNAL_ERROR' type='enum'/>
     <exports symbol='VIR_ERR_CONF_SYNTAX' type='enum'/>
     <exports symbol='VIR_ERR_NO_SUPPORT' type='enum'/>
     <exports symbol='VIR_FROM_XEND' type='enum'/>
     <exports symbol='VIR_FROM_PROXY' type='enum'/>
     <exports symbol='VIR_ERR_READ_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_SEXPR_SERIAL' type='enum'/>
     <exports symbol='VIR_FROM_XENSTORE' type='enum'/>
     <exports symbol='VIR_FROM_XEN' type='enum'/>
     <exports symbol='VIR_ERR_OPEN_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_XEN_CALL' type='enum'/>
     <exports symbol='VIR_ERR_UNKNOWN_HOST' type='enum'/>
     <exports symbol='VIR_ERR_NO_CONNECT' type='enum'/>
     <exports symbol='VIR_ERR_NO_OS' type='enum'/>
     <exports symbol='virErrorPtr' type='typedef'/>
     <exports symbol='virErrorLevel' type='typedef'/>
     <exports symbol='virErrorDomain' type='typedef'/>
     <exports symbol='virErrorNumber' type='typedef'/>
     <exports symbol='virError' type='typedef'/>
     <exports symbol='_virError' type='struct'/>
     <exports symbol='virCopyLastError' type='function'/>
     <exports symbol='virConnSetErrorFunc' type='function'/>
     <exports symbol='virResetLastError' type='function'/>
     <exports symbol='virErrorFunc' type='function'/>
     <exports symbol='virResetError' type='function'/>
     <exports symbol='virConnGetLastError' type='function'/>
     <exports symbol='virDefaultErrorFunc' type='function'/>
     <exports symbol='virGetLastError' type='function'/>
     <exports symbol='virSetErrorFunc' type='function'/>
     <exports symbol='virConnCopyLastError' type='function'/>
     <exports symbol='virConnResetLastError' type='function'/>
    </file>
  </files>
  <symbols>
    <macro name='LIBVIR_VERSION_NUMBER' file='libvirt'>
      <info>Macro providing the version of the library as version * 1,000,000 + minor * 1000 + micro</info>
    </macro>
    <macro name='VIR_COPY_CPUMAP' file='libvirt'>
      <info>This macro is to be used in conjonction with virDomainGetVcpus() and virDomainPinVcpu() APIs. VIR_COPY_CPUMAP macro extract the cpumap of the specified vcpu from cpumaps array and copy it into cpumap to be used later by virDomainPinVcpu() API.</info>
      <arg name='cpumaps' info='pointer to an array of cpumap (in 8-bit bytes) (IN)'/>
      <arg name='maplen' info='the length (in bytes) of one cpumap'/>
      <arg name='vcpu' info='the virtual CPU number'/>
      <arg name='cpumap' info='pointer to a cpumap (in 8-bit bytes) (OUT) This cpumap must be previously allocated by the caller (ie: malloc(maplen))'/>
    </macro>
    <macro name='VIR_CPU_MAPLEN' file='libvirt'>
      <info>This macro is to be used in conjonction with virDomainPinVcpu() API. It returns the length (in bytes) required to store the complete CPU map between a single virtual &amp; all physical CPUs of a domain.</info>
      <arg name='cpu' info='number of physical CPUs'/>
    </macro>
    <macro name='VIR_CPU_USABLE' file='libvirt'>
      <info>This macro is to be used in conjonction with virDomainGetVcpus() API. VIR_CPU_USABLE macro returns a non zero value (true) if the cpu is usable by the vcpu, and 0 otherwise.</info>
      <arg name='cpumaps' info='pointer to an array of cpumap (in 8-bit bytes) (IN)'/>
      <arg name='maplen' info='the length (in bytes) of one cpumap'/>
      <arg name='vcpu' info='the virtual CPU number'/>
      <arg name='cpu' info='the physical CPU number'/>
    </macro>
    <macro name='VIR_GET_CPUMAP' file='libvirt'>
      <info>This macro is to be used in conjonction with virDomainGetVcpus() and virDomainPinVcpu() APIs. VIR_GET_CPUMAP macro returns a pointer to the cpumap of the specified vcpu from cpumaps array.</info>
      <arg name='cpumaps' info='pointer to an array of cpumap (in 8-bit bytes) (IN)'/>
      <arg name='maplen' info='the length (in bytes) of one cpumap'/>
      <arg name='vcpu' info='the virtual CPU number'/>
    </macro>
    <macro name='VIR_NODEINFO_MAXCPUS' file='libvirt'>
      <info>This macro is to calculate the total number of CPUs supported but not neccessarily active in the host.</info>
      <arg name='nodeinfo' info='virNodeInfo instance'/>
    </macro>
    <macro name='VIR_UNUSE_CPU' file='libvirt'>
      <info>This macro is to be used in conjonction with virDomainPinVcpu() API. USE_CPU macro reset the bit (CPU not usable) of the related cpu in cpumap.</info>
      <arg name='cpumap' info='pointer to a bit map of real CPUs (in 8-bit bytes) (IN/OUT)'/>
      <arg name='cpu' info='the physical CPU number'/>
    </macro>
    <macro name='VIR_USE_CPU' file='libvirt'>
      <info>This macro is to be used in conjonction with virDomainPinVcpu() API. USE_CPU macro set the bit (CPU usable) of the related cpu in cpumap.</info>
      <arg name='cpumap' info='pointer to a bit map of real CPUs (in 8-bit bytes) (IN/OUT)'/>
      <arg name='cpu' info='the physical CPU number'/>
    </macro>
    <enum name='VIR_DEVICE_DEFAULT' file='libvirt' value='0' type='virDeviceMode' info='Default mode'/>
    <enum name='VIR_DEVICE_RO' file='libvirt' value='1' type='virDeviceMode' info='Access read-only'/>
    <enum name='VIR_DEVICE_RW' file='libvirt' value='2' type='virDeviceMode' info='Access read-write'/>
    <enum name='VIR_DEVICE_RW_FORCE' file='libvirt' value='3' type='virDeviceMode' info=' Forced read-write even if already used'/>
    <enum name='VIR_DOMAIN_BLOCKED' file='libvirt' value='2' type='virDomainState' info='the domain is blocked on resource'/>
    <enum name='VIR_DOMAIN_CRASHED' file='libvirt' value='6' type='virDomainState' info=' the domain is crashed'/>
    <enum name='VIR_DOMAIN_DESTROY' file='libvirt' value='1' type='virDomainRestart' info='destroy the domain'/>
    <enum name='VIR_DOMAIN_NONE' file='libvirt' value='0' type='virDomainCreateFlags'/>
    <enum name='VIR_DOMAIN_NOSTATE' file='libvirt' value='0' type='virDomainState' info='no state'/>
    <enum name='VIR_DOMAIN_PAUSED' file='libvirt' value='3' type='virDomainState' info='the domain is paused by user'/>
    <enum name='VIR_DOMAIN_PRESERVE' file='libvirt' value='3' type='virDomainRestart' info='keep as is, need manual destroy, for debug'/>
    <enum name='VIR_DOMAIN_RENAME_RESTART' file='libvirt' value='4' type='virDomainRestart' info=' restart under an new unique name'/>
    <enum name='VIR_DOMAIN_RESTART' file='libvirt' value='2' type='virDomainRestart' info='restart the domain'/>
    <enum name='VIR_DOMAIN_RUNNING' file='libvirt' value='1' type='virDomainState' info='the domain is running'/>
    <enum name='VIR_DOMAIN_SHUTDOWN' file='libvirt' value='4' type='virDomainState' info='the domain is being shut down'/>
    <enum name='VIR_DOMAIN_SHUTOFF' file='libvirt' value='5' type='virDomainState' info='the domain is shut off'/>
    <enum name='VIR_ERR_CALL_FAILED' file='virterror' value='26' type='virErrorNumber' info='not supported by the drivers'/>
    <enum name='VIR_ERR_CONF_SYNTAX' file='virterror' value='33' type='virErrorNumber' info='failed to parse the syntax of a conf file'/>
    <enum name='VIR_ERR_DOM_EXIST' file='virterror' value='28' type='virErrorNumber' info='the domain already exist'/>
    <enum name='VIR_ERR_DRIVER_FULL' file='virterror' value='25' type='virErrorNumber' info='too many drivers registered'/>
    <enum name='VIR_ERR_ERROR' file='virterror' value='2' type='virErrorLevel' info=' An error'/>
    <enum name='VIR_ERR_GET_FAILED' file='virterror' value='10' type='virErrorNumber' info='a HTTP GET command to failed'/>
    <enum name='VIR_ERR_HTTP_ERROR' file='virterror' value='12' type='virErrorNumber' info='unexpected HTTP error code'/>
    <enum name='VIR_ERR_INTERNAL_ERROR' file='virterror' value='1' type='virErrorNumber' info='internal error'/>
    <enum name='VIR_ERR_INVALID_ARG' file='virterror' value='8' type='virErrorNumber' info='invalid function argument'/>
    <enum name='VIR_ERR_INVALID_CONN' file='virterror' value='6' type='virErrorNumber' info='invalid connection object'/>
    <enum name='VIR_ERR_INVALID_DOMAIN' file='virterror' value='7' type='virErrorNumber' info='invalid domain object'/>
    <enum name='VIR_ERR_NONE' file='virterror' value='0' type='virErrorLevel'/>
    <enum name='VIR_ERR_NO_CONNECT' file='virterror' value='5' type='virErrorNumber' info='can&apos;t connect to hypervisor'/>
    <enum name='VIR_ERR_NO_DEVICE' file='virterror' value='23' type='virErrorNumber' info='missing domain devices information'/>
    <enum name='VIR_ERR_NO_KERNEL' file='virterror' value='17' type='virErrorNumber' info='missing kernel information'/>
    <enum name='VIR_ERR_NO_MEMORY' file='virterror' value='2' type='virErrorNumber' info='memory allocation failure'/>
    <enum name='VIR_ERR_NO_NAME' file='virterror' value='21' type='virErrorNumber' info='missing domain name information'/>
    <enum name='VIR_ERR_NO_OS' file='virterror' value='22' type='virErrorNumber' info='missing domain OS information'/>
    <enum name='VIR_ERR_NO_ROOT' file='virterror' value='18' type='virErrorNumber' info='missing root device information'/>
    <enum name='VIR_ERR_NO_SOURCE' file='virterror' value='19' type='virErrorNumber' info='missing source device information'/>
    <enum name='VIR_ERR_NO_SUPPORT' file='virterror' value='3' type='virErrorNumber' info='no support for this connection'/>
    <enum name='VIR_ERR_NO_TARGET' file='virterror' value='20' type='virErrorNumber' info='missing target device information'/>
    <enum name='VIR_ERR_NO_XEN' file='virterror' value='14' type='virErrorNumber' info='could not open Xen hypervisor control'/>
    <enum name='VIR_ERR_NO_XENSTORE' file='virterror' value='24' type='virErrorNumber' info='could not open Xen Store control'/>
    <enum name='VIR_ERR_OK' file='virterror' value='0' type='virErrorNumber'/>
    <enum name='VIR_ERR_OPEN_FAILED' file='virterror' value='30' type='virErrorNumber' info='failed to open a conf file'/>
    <enum name='VIR_ERR_OPERATION_DENIED' file='virterror' value='29' type='virErrorNumber' info='operation forbidden on read-only connections'/>
    <enum name='VIR_ERR_OPERATION_FAILED' file='virterror' value='9' type='virErrorNumber' info='a command to hypervisor failed'/>
    <enum name='VIR_ERR_OS_TYPE' file='virterror' value='16' type='virErrorNumber' info='unknown OS type'/>
    <enum name='VIR_ERR_PARSE_FAILED' file='virterror' value='32' type='virErrorNumber' info='failed to parse a conf file'/>
    <enum name='VIR_ERR_POST_FAILED' file='virterror' value='11' type='virErrorNumber' info='a HTTP POST command to failed'/>
    <enum name='VIR_ERR_READ_FAILED' file='virterror' value='31' type='virErrorNumber' info='failed to read a conf file'/>
    <enum name='VIR_ERR_SEXPR_SERIAL' file='virterror' value='13' type='virErrorNumber' info='failure to serialize an S-Expr'/>
    <enum name='VIR_ERR_UNKNOWN_HOST' file='virterror' value='4' type='virErrorNumber' info='could not resolve hostname'/>
    <enum name='VIR_ERR_WARNING' file='virterror' value='1' type='virErrorLevel' info='A simple warning'/>
    <enum name='VIR_ERR_WRITE_FAILED' file='virterror' value='34' type='virErrorNumber' info=' failed to write a conf file'/>
    <enum name='VIR_ERR_XEN_CALL' file='virterror' value='15' type='virErrorNumber' info='failure doing an hypervisor call'/>
    <enum name='VIR_ERR_XML_ERROR' file='virterror' value='27' type='virErrorNumber' info='an XML description is not well formed or broken'/>
    <enum name='VIR_FROM_CONF' file='virterror' value='9' type='virErrorDomain' info=' Error in the configuration file handling'/>
    <enum name='VIR_FROM_DOM' file='virterror' value='6' type='virErrorDomain' info='Error when operating on a domain'/>
    <enum name='VIR_FROM_NONE' file='virterror' value='0' type='virErrorDomain'/>
    <enum name='VIR_FROM_PROXY' file='virterror' value='8' type='virErrorDomain' info='Error in the proxy code'/>
    <enum name='VIR_FROM_RPC' file='virterror' value='7' type='virErrorDomain' info='Error in the XML-RPC code'/>
    <enum name='VIR_FROM_SEXPR' file='virterror' value='4' type='virErrorDomain' info='Error in the S-Epression code'/>
    <enum name='VIR_FROM_XEN' file='virterror' value='1' type='virErrorDomain' info='Error at Xen hypervisor layer'/>
    <enum name='VIR_FROM_XEND' file='virterror' value='2' type='virErrorDomain' info='Error at connection with xend daemon'/>
    <enum name='VIR_FROM_XENSTORE' file='virterror' value='3' type='virErrorDomain' info='Error at connection with xen store'/>
    <enum name='VIR_FROM_XML' file='virterror' value='5' type='virErrorDomain' info='Error in the XML code'/>
    <enum name='VIR_VCPU_BLOCKED' file='libvirt' value='2' type='virVcpuState' info=' the virtual CPU is blocked on resource'/>
    <enum name='VIR_VCPU_OFFLINE' file='libvirt' value='0' type='virVcpuState' info='the virtual CPU is offline'/>
    <enum name='VIR_VCPU_RUNNING' file='libvirt' value='1' type='virVcpuState' info='the virtual CPU is running'/>
    <struct name='virConnect' file='libvirt' type='struct _virConnect'/>
    <typedef name='virConnectPtr' file='libvirt' type='virConnect *'>
      <info>a virConnectPtr is pointer to a virConnect private structure, this is the type used to reference a connection to the Xen Hypervisor in the API.</info>
    </typedef>
    <typedef name='virDeviceMode' file='libvirt' type='enum'/>
    <struct name='virDomain' file='libvirt' type='struct _virDomain'/>
    <typedef name='virDomainCreateFlags' file='libvirt' type='enum'/>
    <struct name='virDomainInfo' file='libvirt' type='struct _virDomainInfo'>
      <field name='state' type='unsigned char' info=' the running state, one of virDomainFlags'/>
      <field name='maxMem' type='unsigned long' info=' the maximum memory in KBytes allowed'/>
      <field name='memory' type='unsigned long' info=' the memory in KBytes used by the domain'/>
      <field name='nrVirtCpu' type='unsigned short' info=' the number of virtual CPUs for the domain'/>
      <field name='cpuTime' type='unsigned long long' info=' the CPU time used in nanoseconds'/>
    </struct>
    <typedef name='virDomainInfoPtr' file='libvirt' type='virDomainInfo *'>
      <info>a virDomainInfoPtr is a pointer to a virDomainInfo structure.</info>
    </typedef>
    <struct name='virDomainKernel' file='libvirt' type='struct _virDomainKernel'>
      <field name='kernel' type='const char *' info=' filename pointing to the kernel image'/>
      <field name='ramdisk' type='const char *' info=' an optional init ramdisk'/>
      <field name='root' type='const char *' info=' an optional root block device'/>
      <field name='extra' type='const char *' info=' optional kernel command line parameters'/>
    </struct>
    <typedef name='virDomainKernelPtr' file='libvirt' type='virDomainKernel *'>
      <info>a virDomainKernelPtr is a pointer to a virDomainKernel structure.</info>
    </typedef>
    <typedef name='virDomainPtr' file='libvirt' type='virDomain *'>
      <info>a virDomainPtr is pointer to a virDomain private structure, this is the type used to reference a Xen domain in the API.</info>
    </typedef>
    <typedef name='virDomainRestart' file='libvirt' type='enum'/>
    <typedef name='virDomainState' file='libvirt' type='enum'/>
    <struct name='virError' file='virterror' type='struct _virError'>
      <field name='code' type='int' info=' The error code, a virErrorNumber'/>
      <field name='domain' type='int' info=' What part of the library raised this error'/>
      <field name='message' type='char *' info=' human-readable informative error message'/>
      <field name='level' type='virErrorLevel' info=' how consequent is the error'/>
      <field name='conn' type='virConnectPtr' info=' the connection if available'/>
      <field name='dom' type='virDomainPtr' info=' the domain if available'/>
      <field name='str1' type='char *' info=' extra string information'/>
      <field name='str2' type='char *' info=' extra string information'/>
      <field name='str3' type='char *' info=' extra string information'/>
      <field name='int1' type='int' info=' extra number information'/>
      <field name='int2' type='int' info=' extra number information'/>
    </struct>
    <typedef name='virErrorDomain' file='virterror' type='enum'/>
    <typedef name='virErrorLevel' file='virterror' type='enum'/>
    <typedef name='virErrorNumber' file='virterror' type='enum'/>
    <typedef name='virErrorPtr' file='virterror' type='virError *'/>
    <struct name='virNodeInfo' file='libvirt' type='struct _virNodeInfo'>
      <field name='model' type='charmodel[32]' info=' string indicating the CPU model'/>
      <field name='memory' type='unsigned long' info=' memory size in kilobytes'/>
      <field name='cpus' type='unsigned int' info=' the number of active CPUs'/>
      <field name='mhz' type='unsigned int' info=' expected CPU frequency'/>
      <field name='nodes' type='unsigned int' info=' the number of NUMA cell, 1 for uniform mem access'/>
      <field name='sockets' type='unsigned int' info=' number of CPU socket per node'/>
      <field name='cores' type='unsigned int' info=' number of core per socket'/>
      <field name='threads' type='unsigned int' info=' number of threads per core'/>
    </struct>
    <typedef name='virNodeInfoPtr' file='libvirt' type='virNodeInfo *'>
      <info>a virNodeInfoPtr is a pointer to a virNodeInfo structure.</info>
    </typedef>
    <struct name='virVcpuInfo' file='libvirt' type='struct _virVcpuInfo'>
      <field name='number' type='unsigned int' info=' virtual CPU number'/>
      <field name='state' type='int' info=' value from virVcpuState'/>
      <field name='cpuTime' type='unsigned long long' info=' CPU time used, in nanoseconds'/>
      <field name='cpu' type='int' info=' real CPU number, or -1 if offline'/>
    </struct>
    <typedef name='virVcpuInfoPtr' file='libvirt' type='virVcpuInfo *'/>
    <typedef name='virVcpuState' file='libvirt' type='enum'/>
    <function name='virConnCopyLastError' file='virterror' module='virterror'>
      <info>Copy the content of the last error caught on that connection One will need to free the result with virResetError()</info>
      <return type='int' info='0 if no error was found and the error code otherwise and -1 in case of parameter error.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='to' type='virErrorPtr' info='target to receive the copy'/>
    </function>
    <function name='virConnGetLastError' file='virterror' module='virterror'>
      <info>Provide a pointer to the last error caught on that connection Simpler but may not be suitable for multithreaded accesses, in which case use virConnCopyLastError()</info>
      <return type='virErrorPtr' info='a pointer to the last error or NULL if none occured.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnResetLastError' file='virterror' module='virterror'>
      <info>Reset the last error caught on that connection</info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnSetErrorFunc' file='virterror' module='virterror'>
      <info>Set a connection error handling function, if @handler is NULL it will reset to default which is to pass error back to the global library handler.</info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='userData' type='void *' info='pointer to the user data provided in the handler callback'/>
      <arg name='handler' type='virErrorFunc' info='the function to get called in case of error or NULL'/>
    </function>
    <function name='virConnectClose' file='libvirt' module='libvirt'>
      <info>This function closes the connection to the Hypervisor. This should not be called if further interaction with the Hypervisor are needed especially if there is running domain which need further monitoring by the application.</info>
      <return type='int' info='0 in case of success or -1 in case of error.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectGetType' file='libvirt' module='libvirt'>
      <info>Get the name of the Hypervisor software used.</info>
      <return type='const char *' info='NULL in case of error, a static zero terminated string otherwise.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectGetVersion' file='libvirt' module='libvirt'>
      <info>Get the version level of the Hypervisor running. This may work only with hypervisor call, i.e. with priviledged access to the hypervisor, not with a Read-Only connection.</info>
      <return type='int' info='-1 in case of error, 0 otherwise. if the version can&apos;t be extracted by lack of capacities returns 0 and @hvVer is 0, otherwise @hvVer value is major * 1,000,000 + minor * 1,000 + release'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='hvVer' type='unsigned long *' info='return value for the version of the running hypervisor (OUT)'/>
    </function>
    <function name='virConnectListDefinedDomains' file='libvirt' module='libvirt'>
      <info>list the defined domains, stores the pointers to the names in @names</info>
      <return type='int' info='the number of names provided in the array or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='names' type='const char **' info='pointer to an array to store the names'/>
      <arg name='maxnames' type='int' info='size of the array'/>
    </function>
    <function name='virConnectListDomains' file='libvirt' module='libvirt'>
      <info>Collect the list of active domains, and store their ID in @maxids</info>
      <return type='int' info='the number of domain found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='ids' type='int *' info='array to collect the list of IDs of active domains'/>
      <arg name='maxids' type='int' info='size of @ids'/>
    </function>
    <function name='virConnectNumOfDefinedDomains' file='libvirt' module='libvirt'>
      <info>Provides the number of active domains.</info>
      <return type='int' info='the number of domain found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectNumOfDomains' file='libvirt' module='libvirt'>
      <info>Provides the number of active domains.</info>
      <return type='int' info='the number of domain found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectOpen' file='libvirt' module='libvirt'>
      <info>This function should be called first to get a connection to the Hypervisor and xen store</info>
      <return type='virConnectPtr' info='a pointer to the hypervisor connection or NULL in case of error'/>
      <arg name='name' type='const char *' info='optional argument currently unused, pass NULL'/>
    </function>
    <function name='virConnectOpenReadOnly' file='libvirt' module='libvirt'>
      <info>This function should be called first to get a restricted connection to the libbrary functionalities. The set of APIs usable are then restricted on the available methods to control the domains.</info>
      <return type='virConnectPtr' info='a pointer to the hypervisor connection or NULL in case of error'/>
      <arg name='name' type='const char *' info='optional argument currently unused, pass NULL'/>
    </function>
    <function name='virCopyLastError' file='virterror' module='virterror'>
      <info>Copy the content of the last error caught at the library level One will need to free the result with virResetError()</info>
      <return type='int' info='0 if no error was found and the error code otherwise and -1 in case of parameter error.'/>
      <arg name='to' type='virErrorPtr' info='target to receive the copy'/>
    </function>
    <function name='virDefaultErrorFunc' file='virterror' module='virterror'>
      <info>Default routine reporting an error to stderr.</info>
      <return type='void'/>
      <arg name='err' type='virErrorPtr' info='pointer to the error.'/>
    </function>
    <function name='virDomainCreate' file='libvirt' module='libvirt'>
      <info>launch a defined domain. If the call succeed the domain moves from the defined to the running domains pools.</info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='domain' type='virDomainPtr' info='pointer to a defined domain'/>
    </function>
    <function name='virDomainCreateLinux' file='libvirt' module='libvirt'>
      <info>Launch a new Linux guest domain, based on an XML description similar to the one returned by virDomainGetXMLDesc() This function may requires priviledged access to the hypervisor.</info>
      <return type='virDomainPtr' info='a new domain object or NULL in case of failure'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='xmlDesc' type='const char *' info='an XML description of the domain'/>
      <arg name='flags' type='unsigned int' info='an optional set of virDomainFlags'/>
    </function>
    <function name='virDomainDefineXML' file='libvirt' module='libvirt'>
      <info>define a domain, but does not start it</info>
      <return type='virDomainPtr' info='NULL in case of error, a pointer to the domain otherwise'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='xml' type='const char *' info='the XML description for the domain, preferably in UTF-8'/>
    </function>
    <function name='virDomainDestroy' file='libvirt' module='libvirt'>
      <info>Destroy the domain object. The running instance is shutdown if not down already and all resources used by it are given back to the hypervisor. The data structure is freed and should not be used thereafter if the call does not return an error. This function may requires priviledged access</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainFree' file='libvirt' module='libvirt'>
      <info>Free the domain object. The running instance is kept alive. The data structure is freed and should not be used thereafter.</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainGetID' file='libvirt' module='libvirt'>
      <info>Get the hypervisor ID number for the domain</info>
      <return type='unsigned int' info='the domain ID number or (unsigned int) -1 in case of error'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainGetInfo' file='libvirt' module='libvirt'>
      <info>Extract information about a domain. Note that if the connection used to get the domain is limited only a partial set of the information can be extracted.</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='info' type='virDomainInfoPtr' info='pointer to a virDomainInfo structure allocated by the user'/>
    </function>
    <function name='virDomainGetMaxMemory' file='libvirt' module='libvirt'>
      <info>Retrieve the maximum amount of physical memory allocated to a domain. If domain is NULL, then this get the amount of memory reserved to Domain0 i.e. the domain where the application runs.</info>
      <return type='unsigned long' info='the memory size in kilobytes or 0 in case of error.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object or NULL'/>
    </function>
    <function name='virDomainGetName' file='libvirt' module='libvirt'>
      <info>Get the public name for that domain</info>
      <return type='const char *' info='a pointer to the name or NULL, the string need not be deallocated its lifetime will be the same as the domain object.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainGetOSType' file='libvirt' module='libvirt'>
      <info>Get the type of domain operation system.</info>
      <return type='char *' info='the new string or NULL in case of error, the string must be freed by the caller.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainGetUUID' file='libvirt' module='libvirt'>
      <info>Get the UUID for a domain</info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='uuid' type='unsigned char *' info='pointer to a 16 bytes array'/>
    </function>
    <function name='virDomainGetUUIDString' file='libvirt' module='libvirt'>
      <info>Get the UUID for a domain as string. For more information about UUID see RFC4122.</info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='buf' type='char *' info='pointer to a 37 bytes array'/>
    </function>
    <function name='virDomainGetVcpus' file='libvirt' module='libvirt'>
      <info>Extract information about virtual CPUs of domain, store it in info array and also in cpumaps if this pointer is&apos;nt NULL.</info>
      <return type='int' info='the number of info filled in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object, or NULL for Domain0'/>
      <arg name='info' type='virVcpuInfoPtr' info='pointer to an array of virVcpuInfo structures (OUT)'/>
      <arg name='maxinfo' type='int' info='number of structures in info array'/>
      <arg name='cpumaps' type='unsigned char *' info='pointer to an bit map of real CPUs for all vcpus of this domain (in 8-bit bytes) (OUT) If cpumaps is NULL, then no cupmap information is returned by the API. It&apos;s assumed there is &lt;maxinfo&gt; cpumap in cpumaps array. The memory allocated to cpumaps must be (maxinfo * maplen) bytes (ie: calloc(maxinfo, maplen)). One cpumap inside cpumaps has the format described in virDomainPinVcpu() API.'/>
      <arg name='maplen' type='int' info='number of bytes in one cpumap, from 1 up to size of CPU map in underlying virtualization system (Xen...).'/>
    </function>
    <function name='virDomainGetXMLDesc' file='libvirt' module='libvirt'>
      <info>Provide an XML description of the domain. The description may be reused later to relaunch the domain with virDomainCreateLinux().</info>
      <return type='char *' info='a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='flags' type='int' info='and OR&apos;ed set of extraction flags, not used yet'/>
    </function>
    <function name='virDomainLookupByID' file='libvirt' module='libvirt'>
      <info>Try to find a domain based on the hypervisor ID number</info>
      <return type='virDomainPtr' info='a new domain object or NULL in case of failure'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='id' type='int' info='the domain ID number'/>
    </function>
    <function name='virDomainLookupByName' file='libvirt' module='libvirt'>
      <info>Try to lookup a domain on the given hypervisor based on its name.</info>
      <return type='virDomainPtr' info='a new domain object or NULL in case of failure'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='name' type='const char *' info='name for the domain'/>
    </function>
    <function name='virDomainLookupByUUID' file='libvirt' module='libvirt'>
      <info>Try to lookup a domain on the given hypervisor based on its UUID.</info>
      <return type='virDomainPtr' info='a new domain object or NULL in case of failure'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='uuid' type='const unsigned char *' info='the raw UUID for the domain'/>
    </function>
    <function name='virDomainLookupByUUIDString' file='libvirt' module='libvirt'>
      <info>Try to lookup a domain on the given hypervisor based on its UUID.</info>
      <return type='virDomainPtr' info='a new domain object or NULL in case of failure'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='uuidstr' type='const char *' info='the string UUID for the domain'/>
    </function>
    <function name='virDomainPinVcpu' file='libvirt' module='libvirt'>
      <info>Dynamically change the real CPUs which can be allocated to a virtual CPU. This function requires priviledged access to the hypervisor.</info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object, or NULL for Domain0'/>
      <arg name='vcpu' type='unsigned int' info='virtual CPU number'/>
      <arg name='cpumap' type='unsigned char *' info='pointer to a bit map of real CPUs (in 8-bit bytes) (IN) Each bit set to 1 means that corresponding CPU is usable. Bytes are stored in little-endian order: CPU0-7, 8-15... In each byte, lowest CPU number is least significant bit.'/>
      <arg name='maplen' type='int' info='number of bytes in cpumap, from 1 up to size of CPU map in underlying virtualization system (Xen...). If maplen &lt; size, missing bytes are set to zero. If maplen &gt; size, failure code is returned.'/>
    </function>
    <function name='virDomainReboot' file='libvirt' module='libvirt'>
      <info>Reboot a domain, the domain object is still usable there after but the domain OS is being stopped for a restart. Note that the guest OS may ignore the request.</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='flags' type='unsigned int' info='extra flags for the reboot operation, not used yet'/>
    </function>
    <function name='virDomainRestore' file='libvirt' module='libvirt'>
      <info>This method will restore a domain saved to disk by virDomainSave().</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='from' type='const char *' info='path to the'/>
    </function>
    <function name='virDomainResume' file='libvirt' module='libvirt'>
      <info>Resume an suspended domain, the process is restarted from the state where it was frozen by calling virSuspendDomain(). This function may requires priviledged access</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainSave' file='libvirt' module='libvirt'>
      <info>This method will suspend a domain and save its memory contents to a file on disk. After the call, if successful, the domain is not listed as running anymore (this may be a problem). Use virDomainRestore() to restore a domain after saving.</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='to' type='const char *' info='path for the output file'/>
    </function>
    <function name='virDomainSetMaxMemory' file='libvirt' module='libvirt'>
      <info>Dynamically change the maximum amount of physical memory allocated to a domain. If domain is NULL, then this change the amount of memory reserved to Domain0 i.e. the domain where the application runs. This function requires priviledged access to the hypervisor.</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object or NULL'/>
      <arg name='memory' type='unsigned long' info='the memory size in kilobytes'/>
    </function>
    <function name='virDomainSetMemory' file='libvirt' module='libvirt'>
      <info>Dynamically change the target amount of physical memory allocated to a domain. If domain is NULL, then this change the amount of memory reserved to Domain0 i.e. the domain where the application runs. This function may requires priviledged access to the hypervisor.</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object or NULL'/>
      <arg name='memory' type='unsigned long' info='the memory size in kilobytes'/>
    </function>
    <function name='virDomainSetVcpus' file='libvirt' module='libvirt'>
      <info>Dynamically change the number of virtual CPUs used by the domain. Note that this call may fail if the underlying virtualization hypervisor does not support it or if growing the number is arbitrary limited. This function requires priviledged access to the hypervisor.</info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object, or NULL for Domain0'/>
      <arg name='nvcpus' type='unsigned int' info='the new number of virtual CPUs for this domain'/>
    </function>
    <function name='virDomainShutdown' file='libvirt' module='libvirt'>
      <info>Shutdown a domain, the domain object is still usable there after but the domain OS is being stopped. Note that the guest OS may ignore the request.  TODO: should we add an option for reboot, knowing it may not be doable in the general case ?</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainSuspend' file='libvirt' module='libvirt'>
      <info>Suspends an active domain, the process is frozen without further access to CPU resources and I/O but the memory used by the domain at the hypervisor level will stay allocated. Use virDomainResume() to reactivate the domain. This function may requires priviledged access.</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainUndefine' file='libvirt' module='libvirt'>
      <info>undefine a domain but does not stop it if it is running</info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='domain' type='virDomainPtr' info='pointer to a defined domain'/>
    </function>
    <functype name='virErrorFunc' file='virterror' module='virterror'>
      <info>Signature of a function to use when there is an error raised by the library.</info>
      <return type='void'/>
      <arg name='userData' type='void *' info='user provided data for the error callback'/>
      <arg name='error' type='virErrorPtr' info='the error being raised.'/>
    </functype>
    <function name='virGetLastError' file='virterror' module='virterror'>
      <info>Provide a pointer to the last error caught at the library level Simpler but may not be suitable for multithreaded accesses, in which case use virCopyLastError()</info>
      <return type='virErrorPtr' info='a pointer to the last error or NULL if none occured.'/>
    </function>
    <function name='virGetVersion' file='libvirt' module='libvirt'>
      <info>Provides two information back, @libVer is the version of the library while @typeVer will be the version of the hypervisor type @type against which the library was compiled. If @type is NULL, &quot;Xen&quot; is assumed, if @type is unknown or not availble, an error code will be returned and @typeVer will be 0.</info>
      <return type='int' info='-1 in case of failure, 0 otherwise, and values for @libVer and @typeVer have the format major * 1,000,000 + minor * 1,000 + release.'/>
      <arg name='libVer' type='unsigned long *' info='return value for the library version (OUT)'/>
      <arg name='type' type='const char *' info='the type of connection/driver looked at'/>
      <arg name='typeVer' type='unsigned long *' info='return value for the version of the hypervisor (OUT)'/>
    </function>
    <function name='virInitialize' file='libvirt' module='libvirt'>
      <info>Initialize the library. It&apos;s better to call this routine at startup in multithreaded applications to avoid potential race when initializing the library.</info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
    </function>
    <function name='virNodeGetInfo' file='libvirt' module='libvirt'>
      <info>Extract hardware information about the node.</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='info' type='virNodeInfoPtr' info='pointer to a virNodeInfo structure allocated by the user'/>
    </function>
    <function name='virResetError' file='virterror' module='virterror'>
      <info>Reset the error being pointed to</info>
      <return type='void'/>
      <arg name='err' type='virErrorPtr' info='pointer to the virError to clean up'/>
    </function>
    <function name='virResetLastError' file='virterror' module='virterror'>
      <info>Reset the last error caught at the library level.</info>
      <return type='void'/>
    </function>
    <function name='virSetErrorFunc' file='virterror' module='virterror'>
      <info>Set a library global error handling function, if @handler is NULL, it will reset to default printing on stderr. The error raised there are those for which no handler at the connection level could caught.</info>
      <return type='void'/>
      <arg name='userData' type='void *' info='pointer to the user data provided in the handler callback'/>
      <arg name='handler' type='virErrorFunc' info='the function to get called in case of error or NULL'/>
    </function>
  </symbols>
</api>
